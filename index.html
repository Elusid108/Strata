<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strata - Digital Notebook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config = { darkMode: 'class' };</script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://apis.google.com/js/picker.js"></script>
    <script src="config.js"></script>
    <script src="google-api.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
    <style>/* DocNotes Webapp Styles */

/* List Styles for Nested Lists */
ul { list-style-type: disc !important; }
ul ul { list-style-type: circle !important; }
ul ul ul { list-style-type: square !important; }
ol { list-style-type: decimal !important; }
ol ol { list-style-type: lower-alpha !important; }
ol ol ol { list-style-type: lower-roman !important; }

/* Hide Scrollbar */
.no-scrollbar::-webkit-scrollbar { display: none; }
.no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

/* Base styles */
body { margin: 0; padding: 0; background-color: #f9fafb; height: 100vh; overflow: hidden; }
#root { height: 100%; }

/* Focus styles for page navigation */
.page-item:focus { outline: 2px solid #3b82f6; outline-offset: -2px; background-color: #f3f4f6; }

/* Dark mode styles */
html.dark body { background-color: #111827; }
html.dark .bg-white { background-color: #1f2937 !important; }
html.dark .bg-gray-50 { background-color: #111827 !important; }
html.dark .bg-gray-100 { background-color: #1f2937 !important; }
html.dark .text-gray-800 { color: #f3f4f6 !important; }
html.dark .text-gray-700 { color: #d1d5db !important; }
html.dark .text-gray-600 { color: #9ca3af !important; }
html.dark .text-gray-500 { color: #9ca3af !important; }
html.dark .text-gray-400 { color: #6b7280 !important; }
html.dark .border-gray-200 { border-color: #374151 !important; }
html.dark .border-gray-300 { border-color: #4b5563 !important; }
html.dark .border-gray-100 { border-color: #374151 !important; }
html.dark .hover\:bg-gray-50:hover { background-color: #374151 !important; }
html.dark .hover\:bg-gray-100:hover { background-color: #374151 !important; }
html.dark input:not(.bg-transparent), html.dark textarea:not(.bg-transparent) { background-color: #374151; color: #f3f4f6; border-color: #4b5563; }
html.dark input.bg-transparent { background-color: transparent; color: #f3f4f6; }
html.dark input::placeholder { color: #6b7280; }
html.dark .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.3); }
html.dark .shadow-inner { box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3); }
html.dark [contenteditable="true"] { color: #f3f4f6; }
html.dark .page-item:focus { background-color: #374151; }
/* Dark mode for pages sidebar */
html.dark .page-item { color: #f3f4f6; }
html.dark .page-item:hover { background-color: #374151 !important; }
html.dark .page-item.bg-gray-100 { background-color: #374151 !important; }

/* Glossy tab border effect */
.tab-gloss {
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.25),
        inset 1px 0 0 rgba(255, 255, 255, 0.15),
        inset -1px 0 0 rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-bottom: none;
}

html.dark .tab-gloss {
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.15),
        inset 1px 0 0 rgba(255, 255, 255, 0.1),
        inset -1px 0 0 rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.2);
}

/* Canvas grid pattern */
.canvas-grid {
    background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
}

html.dark .canvas-grid {
    background-image: radial-gradient(#4b5563 1px, transparent 1px);
}

/* Animations */
@keyframes fade-in { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
.animate-fade-in { animation: fade-in 0.15s ease-out; }
@keyframes bounce-in { 0% { transform: scale(0.9); opacity: 0; } 50% { transform: scale(1.02); } 100% { transform: scale(1); opacity: 1; } }
.animate-bounce-in { animation: bounce-in 0.3s ease-out; }
</style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">  const { useState, useEffect, useRef, useLayoutEffect, useCallback, memo } = React;

  // --- App Version ---
  const APP_VERSION = "2.5.9";

  // --- Offline Viewer HTML Generator ---
  const generateOfflineViewerHtml = () => {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strata Notebooks - Offline Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #333; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 280px; background: #1f2937; color: white; overflow-y: auto; flex-shrink: 0; }
        .sidebar-header { padding: 16px; border-bottom: 1px solid #374151; font-weight: bold; font-size: 18px; }
        .notebook { margin: 8px; }
        .notebook-header { padding: 8px 12px; background: #374151; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .notebook-header:hover { background: #4b5563; }
        .notebook-header.active { background: #3b82f6; }
        .tab { margin-left: 16px; margin-top: 4px; }
        .tab-header { padding: 6px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px; }
        .tab-header:hover { background: #374151; }
        .tab-header.active { background: #4b5563; }
        .page { margin-left: 32px; }
        .page-item { padding: 4px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 13px; color: #9ca3af; }
        .page-item:hover { background: #374151; color: white; }
        .page-item.active { background: #3b82f6; color: white; }
        .main { flex: 1; overflow-y: auto; background: white; }
        .page-content { max-width: 800px; margin: 0 auto; padding: 40px; }
        .page-title { font-size: 32px; font-weight: bold; margin-bottom: 24px; display: flex; align-items: center; gap: 12px; }
        .block { margin-bottom: 8px; line-height: 1.6; }
        .block-h1 { font-size: 28px; font-weight: bold; margin-top: 24px; margin-bottom: 12px; }
        .block-h2 { font-size: 24px; font-weight: bold; margin-top: 20px; margin-bottom: 10px; }
        .block-h3 { font-size: 20px; font-weight: bold; margin-top: 16px; margin-bottom: 8px; }
        .block-h4 { font-size: 16px; font-weight: bold; margin-top: 12px; margin-bottom: 6px; }
        .block-ul, .block-ol { padding-left: 24px; }
        .block-todo { display: flex; align-items: center; gap: 8px; }
        .block-todo input { width: 18px; height: 18px; }
        .block-divider { border-top: 1px solid #e5e7eb; margin: 16px 0; }
        .block-image img { max-width: 100%; border-radius: 8px; }
        .block-link a { color: #3b82f6; text-decoration: none; }
        .block-link a:hover { text-decoration: underline; }
        .block-video iframe { width: 100%; aspect-ratio: 16/9; border: none; border-radius: 8px; }
        .google-link { padding: 16px; background: #f3f4f6; border-radius: 8px; margin: 8px 0; }
        .google-link a { color: #3b82f6; font-weight: 500; }
        .loading { text-align: center; padding: 40px; color: #666; }
        .error { text-align: center; padding: 40px; color: #dc2626; }
        .empty { text-align: center; padding: 60px; color: #9ca3af; }
        .mermaid-container { min-height: 200px; }
        @media (max-width: 768px) {
            .sidebar { width: 100%; position: fixed; bottom: 0; height: auto; max-height: 50vh; z-index: 100; }
            .main { margin-bottom: 200px; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></scr${''}ipt>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">ðŸ““ Strata Notebooks</div>
            <div id="nav"></div>
        </div>
        <div class="main">
            <div id="content" class="loading">Loading...</div>
        </div>
    </div>
    <script>
        let manifest = null;
        let currentNotebook = null;
        let currentTab = null;
        let currentPage = null;
        let mermaidInitialized = false;
        const PYODIDE_VIEWER_URL = 'https://cdn.jsdelivr.net/pyodide/v0.29.2/full/pyodide.js';
        async function runPythonInViewer(code, outputEl) {
            const out = [];
            const append = function(msg) { out.push(msg); };
            try {
                if (typeof window.loadPyodide !== 'function') {
                    const s = document.createElement('script');
                    s.src = PYODIDE_VIEWER_URL;
                    await new Promise(function(resolve, reject) {
                        s.onload = resolve;
                        s.onerror = function() { reject(new Error('Python requires network (Pyodide).')); };
                        document.head.appendChild(s);
                    });
                }
                if (!window.__pyodide) {
                    outputEl.textContent = 'Loading Pyodide...';
                    window.__pyodide = await loadPyodide();
                }
                outputEl.textContent = 'Running...';
                const pyodide = window.__pyodide;
                pyodide.setStdout({ batched: append });
                pyodide.setStderr({ batched: append });
                await pyodide.loadPackagesFromImports(code);
                const result = pyodide.runPython(code);
                if (result !== undefined) { try { out.push(String(result)); } catch (_) {} }
                outputEl.textContent = out.join('') || '\\u00a0';
                outputEl.style.color = '';
            } catch (e) {
                outputEl.textContent = (e && e.message) ? e.message : String(e);
                outputEl.style.color = '#dc2626';
            }
        }
        async function loadManifest() {
            try {
                const response = await fetch('manifest.json');
                if (!response.ok) throw new Error('Could not load manifest.json');
                manifest = await response.json();
                renderNav();
                if (manifest.notebooks.length > 0) {
                    selectNotebook(manifest.notebooks[0]);
                } else {
                    document.getElementById('content').innerHTML = '<div class="empty">No notebooks found</div>';
                }
            } catch (e) {
                document.getElementById('content').innerHTML = '<div class="error">Error: ' + e.message + '<br><br>Make sure manifest.json is in the same folder as index.html</div>';
            }
        }

        function renderNav() {
            const nav = document.getElementById('nav');
            nav.innerHTML = manifest.notebooks.map(nb => \`
                <div class="notebook">
                    <div class="notebook-header" onclick="selectNotebook(manifest.notebooks.find(n => n.id === '\${nb.id}'))" id="nb-\${nb.id}">
                        <span>\${nb.icon || 'ðŸ““'}</span>
                        <span>\${nb.name}</span>
                    </div>
                    <div class="tabs" id="tabs-\${nb.id}" style="display: none;">
                        \${nb.tabs.map(tab => \`
                            <div class="tab">
                                <div class="tab-header" onclick="selectTab(manifest.notebooks.find(n => n.id === '\${nb.id}'), '\${tab.id}')" id="tab-\${tab.id}">
                                    <span>\${tab.icon || 'ðŸ“‹'}</span>
                                    <span>\${tab.name}</span>
                                </div>
                                <div class="pages" id="pages-\${tab.id}" style="display: none;">
                                    \${tab.pages.map(page => \`
                                        <div class="page">
                                            <div class="page-item" onclick="selectPage('\${nb.id}', '\${tab.id}', '\${page.id}')" id="page-\${page.id}">
                                                <span>\${page.icon || 'ðŸ“„'}</span>
                                                <span>\${page.name}</span>
                                            </div>
                                        </div>
                                    \`).join('')}
                                </div>
                            </div>
                        \`).join('')}
                    </div>
                </div>
            \`).join('');
        }

        function selectNotebook(nb) {
            document.querySelectorAll('.notebook-header').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tabs').forEach(el => el.style.display = 'none');
            document.getElementById('nb-' + nb.id).classList.add('active');
            document.getElementById('tabs-' + nb.id).style.display = 'block';
            currentNotebook = nb;
            if (nb.tabs.length > 0) selectTab(nb, nb.tabs[0].id);
        }

        function selectTab(nb, tabId) {
            const tab = nb.tabs.find(t => t.id === tabId);
            document.querySelectorAll('.tab-header').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.pages').forEach(el => el.style.display = 'none');
            document.getElementById('tab-' + tabId).classList.add('active');
            document.getElementById('pages-' + tabId).style.display = 'block';
            currentTab = tab;
            if (tab.pages.length > 0) selectPage(nb.id, tabId, tab.pages[0].id);
        }

        async function selectPage(nbId, tabId, pageId) {
            document.querySelectorAll('.page-item').forEach(el => el.classList.remove('active'));
            document.getElementById('page-' + pageId).classList.add('active');
            
            const nb = manifest.notebooks.find(n => n.id === nbId);
            const tab = nb.tabs.find(t => t.id === tabId);
            const page = tab.pages.find(p => p.id === pageId);
            currentPage = page;

            if (page.type && page.type !== 'block' && page.type !== 'mermaid') {
                // Google Doc/Sheet/Slides or external link
                const link = page.webViewLink || page.embedUrl || '#';
                document.getElementById('content').innerHTML = \`
                    <div class="page-content">
                        <h1 class="page-title"><span>\${page.icon || 'ðŸ“„'}</span> \${page.name}</h1>
                        <div class="google-link">
                            <p>This is a linked Google file.</p>
                            <p><a href="\${link}" target="_blank">Open in Google Drive â†’</a></p>
                        </div>
                    </div>
                \`;
                return;
            }

            if (page.type === 'mermaid') {
                try {
                    const filePath = nb.folder + '/' + tab.folder + '/' + page.file;
                    const response = await fetch(filePath);
                    if (!response.ok) throw new Error('Could not load page');
                    const pageData = await response.json();
                    const codeType = pageData.codeType || 'mermaid';
                    const code = (pageData.code ?? pageData.mermaidCode ?? '').trim();
                    const icon = page.icon || '</>';
                    let html = '<div class="page-content"><h1 class="page-title"><span>' + icon + '</span> ' + page.name + '</h1>';
                    if (!code) {
                        html += '<div class="empty">No code in this page.</div>';
                    } else if (codeType === 'mermaid') {
                        html += '<div class="mermaid-container" style="min-height:200px"><pre class="mermaid"></pre></div>';
                    } else if (codeType === 'html') {
                        html += '<iframe title="Code output" sandbox="allow-scripts" srcdoc="' + code.replace(/&/g, '&amp;').replace(/"/g, '&quot;') + '" style="width:100%;min-height:400px;border:1px solid #e5e7eb;border-radius:8px;"></iframe>';
                    } else if (codeType === 'javascript') {
                        const esc = code.replace(/<\\/script>/gi, '<\\\\/script>');
                        const wrapped = '<!DOCTYPE html><html><head><meta charset="utf-8"></head><body><script>' + esc + '</scr' + 'ipt></body></html>';
                        html += '<iframe title="Code output" sandbox="allow-scripts" srcdoc="' + wrapped.replace(/&/g, '&amp;').replace(/"/g, '&quot;') + '" style="width:100%;min-height:400px;border:1px solid #e5e7eb;border-radius:8px;"></iframe>';
                    } else if (codeType === 'python') {
                        html += '<div id="pyodide-output" class="pyodide-output" style="white-space:pre-wrap;font-family:monospace;font-size:14px;padding:16px;border:1px solid #e5e7eb;border-radius:8px;min-height:200px;">Loading Pyodide...</div>';
                    } else {
                        html += '<div class="empty">Unsupported code type.</div>';
                    }
                    html += '</div>';
                    document.getElementById('content').innerHTML = html;
                    document.getElementById('content').classList.remove('loading');
                    if (code && codeType === 'mermaid') {
                        const pre = document.querySelector('#content .mermaid');
                        if (pre) {
                            pre.textContent = code;
                            if (typeof mermaid !== 'undefined') {
                                if (!mermaidInitialized) {
                                    mermaid.initialize({ startOnLoad: false });
                                    mermaidInitialized = true;
                                }
                                mermaid.run({ nodes: [pre] }).catch(function() {
                                    const cnt = document.querySelector('#content .mermaid-container');
                                    if (cnt) cnt.innerHTML = '<div class="error">Invalid Mermaid syntax</div>';
                                });
                            }
                        }
                    } else if (code && codeType === 'python') {
                        const el = document.getElementById('pyodide-output');
                        if (el) runPythonInViewer(code, el);
                    }
                } catch (e) {
                    document.getElementById('content').innerHTML = '<div class="error">Could not load page: ' + e.message + '</div>';
                }
                return;
            }

            // Load block page content
            try {
                const filePath = nb.folder + '/' + tab.folder + '/' + page.file;
                const response = await fetch(filePath);
                if (!response.ok) throw new Error('Could not load page');
                const pageData = await response.json();
                renderPage(page, pageData);
            } catch (e) {
                document.getElementById('content').innerHTML = '<div class="error">Could not load page: ' + e.message + '</div>';
            }
        }

        function renderPage(pageMeta, pageData) {
            const content = pageData.content || pageData.rows || [];
            let html = '<div class="page-content">';
            html += '<h1 class="page-title"><span>' + (pageMeta.icon || 'ðŸ“„') + '</span> ' + pageMeta.name + '</h1>';
            
            function renderBlocks(rows) {
                let blocksHtml = '';
                for (const row of rows) {
                    if (!row.columns) continue;
                    for (const col of row.columns) {
                        if (!col.blocks) continue;
                        for (const block of col.blocks) {
                            blocksHtml += renderBlock(block);
                        }
                    }
                }
                return blocksHtml;
            }

            function renderBlock(block) {
                const c = block.content || '';
                switch (block.type) {
                    case 'h1': return '<div class="block block-h1">' + c + '</div>';
                    case 'h2': return '<div class="block block-h2">' + c + '</div>';
                    case 'h3': return '<div class="block block-h3">' + c + '</div>';
                    case 'h4': return '<div class="block block-h4">' + c + '</div>';
                    case 'ul': return '<ul class="block block-ul"><li>' + c + '</li></ul>';
                    case 'ol': return '<ol class="block block-ol"><li>' + c + '</li></ol>';
                    case 'todo': return '<div class="block block-todo"><input type="checkbox" ' + (block.checked ? 'checked' : '') + ' disabled> <span>' + c + '</span></div>';
                    case 'divider': return '<div class="block-divider"></div>';
                    case 'image': return block.url ? '<div class="block block-image"><img src="' + block.url + '" alt=""></div>' : '';
                    case 'video': return block.url ? '<div class="block block-video"><iframe src="https://www.youtube.com/embed/' + getYouTubeId(block.url) + '" allowfullscreen></iframe></div>' : '';
                    case 'link': return '<div class="block block-link"><a href="' + (block.url || '#') + '" target="_blank">' + (c || block.url || 'Link') + '</a></div>';
                    default: return c ? '<div class="block">' + c + '</div>' : '';
                }
            }

            function getYouTubeId(url) {
                const match = url.match(/(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))([^#&?]*)/);
                return match ? match[1] : '';
            }

            if (Array.isArray(content)) {
                html += renderBlocks(content);
            }
            html += '</div>';
            document.getElementById('content').innerHTML = html;
        }

        // Start
        loadManifest();
    </scr${''}ipt>
</body>
</html>`;
  };

  // --- Internal Icon Components ---
  const IconBase = ({ children, size = 24, className = "" }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
      {children}
    </svg>
  );

  const Plus = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="M12 5v14"/></IconBase>;
  const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
  const GripVertical = (props) => <IconBase {...props}><circle cx="9" cy="12" r="1"/><circle cx="9" cy="5" r="1"/><circle cx="9" cy="19" r="1"/><circle cx="15" cy="12" r="1"/><circle cx="15" cy="5" r="1"/><circle cx="15" cy="19" r="1"/></IconBase>;
  const ImageIcon = (props) => <IconBase {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></IconBase>;
  const Youtube = (props) => <IconBase {...props}><path d="M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17"/><path d="m10 15 5-3-5-3z"/></IconBase>;
  const Type = (props) => <IconBase {...props}><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" x2="15" y1="20" y2="20"/><line x1="12" x2="12" y1="4" y2="20"/></IconBase>;
  const LinkIcon = (props) => <IconBase {...props}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconBase>;
  const ChevronRight = (props) => <IconBase {...props}><path d="m9 18 6-6-6-6"/></IconBase>;
  const Book = (props) => <IconBase {...props}><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></IconBase>;
  const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
  const X = (props) => <IconBase {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
  const Minus = (props) => <IconBase {...props}><path d="M5 12h14"/></IconBase>;
  const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase>;
  const ZoomIn = (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></IconBase>;
  const ZoomOut = (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></IconBase>;
  const MoreVertical = (props) => <IconBase {...props}><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></IconBase>;
  const List = (props) => <IconBase {...props}><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></IconBase>;
  const ListOrdered = (props) => <IconBase {...props}><line x1="10" x2="21" y1="6" y2="6"/><line x1="10" x2="21" y1="12" y2="12"/><line x1="10" x2="21" y1="18" y2="18"/><path d="M4 6h1v4"/><path d="M4 10h2"/><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/></IconBase>;
  const Heading1 = (props) => <IconBase {...props}><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="m17 12 3-2v8"/></IconBase>;
  const Heading2 = (props) => <IconBase {...props}><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1"/></IconBase>;
  const Heading3 = (props) => <IconBase {...props}><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"/><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"/></IconBase>;
  const Heading4 = (props) => <IconBase {...props}><path d="M4 12h8"/><path d="M4 18V6"/><path d="M12 18V6"/><path d="M17 10v4h4"/><path d="M21 10v8"/></IconBase>;
  const AlignLeft = (props) => <IconBase {...props}><line x1="17" x2="3" y1="6" y2="6"/><line x1="21" x2="3" y1="12" y2="12"/><line x1="17" x2="3" y1="18" y2="18"/></IconBase>;
  const Bold = (props) => <IconBase {...props}><path d="M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8"/></IconBase>;
  const Italic = (props) => <IconBase {...props}><line x1="19" x2="10" y1="4" y2="4"/><line x1="14" x2="5" y1="20" y2="20"/><line x1="15" x2="9" y1="4" y2="20"/></IconBase>;
  const Underline = (props) => <IconBase {...props}><path d="M6 4v6a6 6 0 0 0 12 0V4"/><line x1="4" x2="20" y1="20" y2="20"/></IconBase>;
  const Strikethrough = (props) => <IconBase {...props}><path d="M16 4H9a3 3 0 0 0-2.83 4"/><path d="M14 12a4 4 0 0 1 0 8H6"/><line x1="4" x2="20" y1="12" y2="12"/></IconBase>;
  const CheckSquare = (props) => <IconBase {...props}><polyline points="9 11 12 14 22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></IconBase>;
  const Image = (props) => <IconBase {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></IconBase>;
  const Moon = (props) => <IconBase {...props}><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></IconBase>;
  const GoogleG = ({ size = 16, className = "" }) => (
    <svg viewBox="0 0 24 24" width={size} height={size} className={className}>
      <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
      <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
      <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
      <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
    </svg>
  );
  const Sun = (props) => <IconBase {...props}><circle cx="12" cy="12" r="5"/><line x1="12" x2="12" y1="1" y2="3"/><line x1="12" x2="12" y1="21" y2="23"/><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"/><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"/><line x1="1" x2="3" y1="12" y2="12"/><line x1="21" x2="23" y1="12" y2="12"/><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"/><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"/></IconBase>;
  const Monitor = (props) => <IconBase {...props}><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" x2="16" y1="21" y2="21"/><line x1="12" x2="12" y1="17" y2="21"/></IconBase>;
  const Columns = (props) => <IconBase {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="12" x2="12" y1="3" y2="21"/></IconBase>;
  const Minimize2 = (props) => <IconBase {...props}><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/></IconBase>;
  const Maximize2 = (props) => <IconBase {...props}><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></IconBase>;
  const Star = ({ size = 24, className = "", filled = false, ...props }) => (
    <svg {...props} xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={filled ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
      <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
    </svg>
  );
  const Edit3 = (props) => <IconBase {...props}><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></IconBase>;
  const FolderOpen = (props) => <IconBase {...props}><path d="m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2"/></IconBase>;
  const FilePlus = (props) => <IconBase {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" x2="12" y1="18" y2="12"/><line x1="9" x2="15" y1="15" y2="15"/></IconBase>;
  const GripHorizontal = (props) => <IconBase {...props}><circle cx="12" cy="9" r="1"/><circle cx="19" cy="9" r="1"/><circle cx="5" cy="9" r="1"/><circle cx="12" cy="15" r="1"/><circle cx="19" cy="15" r="1"/><circle cx="5" cy="15" r="1"/></IconBase>;
  const MousePointer2 = (props) => <IconBase {...props}><path d="m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></IconBase>;
  const Hand = (props) => <IconBase {...props}><path d="M18 11v-1a2 2 0 0 0-2-2h-1"/><path d="M14 10V9a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v1"/><path d="M10 9.5V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v10"/><path d="M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-4a8 8 0 0 1-8-8 2 2 0 0 1 2-2h7z"/></IconBase>;
  const PenTool = (props) => <IconBase {...props}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>;
  const Eraser = (props) => <IconBase {...props}><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></IconBase>;
  const Undo = (props) => <IconBase {...props}><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.7L3 13"/></IconBase>;
  const Redo = (props) => <IconBase {...props}><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.7L21 13"/></IconBase>;
  const Highlighter = (props) => <IconBase {...props}><path d="m9 11-6 6v3h3l6-6"/><path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L12.4 2"/></IconBase>;
  const Move = (props) => <IconBase {...props}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></IconBase>;
  const ArrowRight = (props) => <IconBase {...props}><line x1="5" x2="19" y1="12" y2="12"/><polyline points="12 5 19 12 12 19"/></IconBase>;
  const ToggleLeft = (props) => <IconBase {...props}><rect x="1" y="5" width="22" height="14" rx="7" ry="7"/><circle cx="8" cy="12" r="3"/></IconBase>;
  const Palette = (props) => <IconBase {...props}><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></IconBase>;
  const Circle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/></IconBase>;

  // --- Constants & Utilities ---
  const COLORS = [
    { name: 'gray', label: 'Gray' }, { name: 'red', label: 'Red' }, { name: 'orange', label: 'Orange' },
    { name: 'amber', label: 'Amber' }, { name: 'green', label: 'Green' }, { name: 'teal', label: 'Teal' },
    { name: 'blue', label: 'Blue' }, { name: 'indigo', label: 'Indigo' }, { name: 'purple', label: 'Purple' },
    { name: 'pink', label: 'Pink' },
  ];

  const SLASH_COMMANDS = [
    { cmd: 'h1', aliases: ['h1', 'header1', 'heading1'], label: 'Heading 1', desc: 'Large section heading', type: 'h1' },
    { cmd: 'h2', aliases: ['h2', 'header2', 'heading2'], label: 'Heading 2', desc: 'Medium section heading', type: 'h2' },
    { cmd: 'h3', aliases: ['h3', 'header3', 'heading3'], label: 'Heading 3', desc: 'Small section heading', type: 'h3' },
    { cmd: 'h4', aliases: ['h4', 'header4', 'heading4'], label: 'Heading 4', desc: 'Tiny section heading', type: 'h4' },
    { cmd: 'ul', aliases: ['ul', 'list', 'bullet', 'bullets'], label: 'Bullet List', desc: 'Unordered list', type: 'ul' },
    { cmd: 'ol', aliases: ['ol', 'num', 'ordered', 'numbered'], label: 'Numbered List', desc: 'Ordered list', type: 'ol' },
    { cmd: 'todo', aliases: ['todo', 'check', 'task', 'checkbox'], label: 'To-do', desc: 'Checkbox item', type: 'todo' },
    { cmd: 'img', aliases: ['img', 'image', 'pic', 'picture'], label: 'Image', desc: 'Embed an image', type: 'image' },
    { cmd: 'vid', aliases: ['vid', 'video', 'youtube'], label: 'Video', desc: 'Embed YouTube video', type: 'video' },
    { cmd: 'link', aliases: ['link', 'url', 'bookmark'], label: 'Link', desc: 'Web bookmark', type: 'link' },
    { cmd: 'div', aliases: ['div', 'divider', 'hr', 'line'], label: 'Divider', desc: 'Horizontal line', type: 'divider' },
    { cmd: 'gdoc', aliases: ['gdoc', 'gdrive', 'google'], label: 'Google Drive File', desc: 'Embed Google Doc/Sheet/Slide', type: 'gdoc' },
  ];

  const BLOCK_TYPES = [
    { type: 'text', label: 'Text' },
    ...SLASH_COMMANDS.map(c => ({ type: c.type, label: c.label })),
  ];

  const BG_COLORS = {
      gray: 'bg-gray-100 dark:bg-gray-700',
      red: 'bg-red-100 dark:bg-red-900',
      orange: 'bg-orange-100 dark:bg-orange-900',
      amber: 'bg-amber-100 dark:bg-amber-900',
      green: 'bg-green-100 dark:bg-green-900',
      teal: 'bg-teal-100 dark:bg-teal-900',
      blue: 'bg-blue-100 dark:bg-blue-900',
      indigo: 'bg-indigo-100 dark:bg-indigo-900',
      purple: 'bg-purple-100 dark:bg-purple-900',
      pink: 'bg-pink-100 dark:bg-pink-900',
  };

  const EMOJIS = ["ðŸ˜€", "ðŸ˜ƒ", "ðŸ˜„", "ðŸ˜", "ðŸ˜†", "ðŸ˜…", "ðŸ˜‚", "ðŸ¤£", "ðŸ˜Š", "ðŸ˜‡", "ðŸ™‚", "ðŸ™ƒ", "ðŸ˜‰", "ðŸ˜Œ", "ðŸ˜", "ðŸ¥°", "ðŸ˜˜", "ðŸ˜—", "ðŸ˜™", "ðŸ˜š", "ðŸ˜‹", "ðŸ˜›", "ðŸ˜", "ðŸ˜œ", "ðŸ¤ª", "ðŸ¤¨", "ðŸ§", "ðŸ¤“", "ðŸ˜Ž", "ðŸ¤©", "ðŸ¥³", "ðŸ˜", "ðŸ˜’", "ðŸ˜ž", "ðŸ˜”", "ðŸ˜Ÿ", "ðŸ˜•", "ðŸ™", "â˜¹ï¸", "ðŸ˜£", "ðŸ˜–", "ðŸ˜«", "ðŸ˜©", "ðŸ¥º", "ðŸ˜¢", "ðŸ˜­", "ðŸ˜¤", "ðŸ˜ ", "ðŸ˜¡", "ðŸ¤¬", "ðŸ¤¯", "ðŸ˜³", "ðŸ¥µ", "ðŸ¥¶", "ðŸ˜±", "ðŸ˜¨", "ðŸ˜°", "ðŸ˜¥", "ðŸ˜“", "ðŸ¤—", "ðŸ¤”", "ðŸ¤­", "ðŸ¤«", "ðŸ¤¥", "ðŸ˜¶", "ðŸ˜", "ðŸ˜‘", "ðŸ˜¬", "ðŸ™„", "ðŸ˜¯", "ðŸ˜¦", "ðŸ˜§", "ðŸ˜®", "ðŸ˜²", "ðŸ¥±", "ðŸ˜´", "ðŸ¤¤", "ðŸ˜ª", "ðŸ˜µ", "ðŸ¤", "ðŸ¥´", "ðŸ¤¢", "ðŸ¤®", "ðŸ¤§", "ðŸ˜·", "ðŸ¤’", "ðŸ¤•", "ðŸ¤‘", "ðŸ¤ ", "ðŸ˜ˆ", "ðŸ‘¿", "ðŸ‘¹", "ðŸ‘º", "ðŸ¤¡", "ðŸ’©", "ðŸ‘»", "ðŸ’€", "â˜ ï¸", "ðŸ‘½", "ðŸ‘¾", "ðŸ¤–", "ðŸŽƒ", "ðŸ˜º", "ðŸ˜¸", "ðŸ˜¹", "ðŸ˜»", "ðŸ˜¼", "ðŸ˜½", "ðŸ™€", "ðŸ˜¿", "ðŸ˜¾", "ðŸ‘‹", "ðŸ¤š", "ðŸ–", "âœ‹", "ðŸ––", "ðŸ‘Œ", "ðŸ¤", "âœŒï¸", "ðŸ¤ž", "ðŸ¤Ÿ", "ðŸ¤˜", "ðŸ¤™", "ðŸ‘ˆ", "ðŸ‘‰", "ðŸ‘†", "ðŸ–•", "ðŸ‘‡", "â˜ï¸", "ðŸ‘", "ðŸ‘Ž", "âœŠ", "ðŸ‘Š", "ðŸ¤›", "ðŸ¤œ", "ðŸ‘", "ðŸ™Œ", "ðŸ‘", "ðŸ¤²", "ðŸ¤", "ðŸ™", "âœï¸", "ðŸ’…", "ðŸ¤³", "ðŸ’ª", "ðŸ¦¾", "ðŸ¦µ", "ðŸ¦¶", "ðŸ‘‚", "ðŸ¦»", "ðŸ‘ƒ", "ðŸ§ ", "ðŸ¦·", "ðŸ¦´", "ðŸ‘€", "ðŸ‘", "ðŸ‘…", "ðŸ‘„", "ðŸ‘¶", "ðŸ§’", "ðŸ‘¦", "ðŸ‘§", "ðŸ§‘", "ðŸ‘±", "ðŸ‘¨", "ðŸ§”", "ðŸ‘¨â€ðŸ¦°", "ðŸ‘¨â€ðŸ¦±", "ðŸ‘¨â€ðŸ¦³", "ðŸ‘¨â€ðŸ¦²", "ðŸ‘©", "ðŸ‘©â€ðŸ¦°", "ðŸ‘©â€ðŸ¦±", "ðŸ‘©â€ðŸ¦³", "ðŸ‘©â€ðŸ¦²", "ðŸ‘±â€â™€ï¸", "ðŸ‘±â€â™‚ï¸", "ðŸ§“", "ðŸ‘´", "ðŸ‘µ", "ðŸ™", "ðŸ™â€â™‚ï¸", "ðŸ™â€â™€ï¸", "ðŸ™Ž", "ðŸ™Žâ€â™‚ï¸", "ðŸ™Žâ€â™€ï¸", "ðŸ™…", "ðŸ™…â€â™‚ï¸", "ðŸ™…â€â™€ï¸", "ðŸ™†", "ðŸ™†â€â™‚ï¸", "ðŸ™†â€â™€ï¸", "ðŸ’", "ðŸ’â€â™‚ï¸", "ðŸ’â€â™€ï¸", "ðŸ™‹", "ðŸ™‹â€â™‚ï¸", "ðŸ™‹â€â™€ï¸", "ðŸ§", "ðŸ§â€â™‚ï¸", "ðŸ§â€â™€ï¸", "ðŸ™‡", "ðŸ™‡â€â™‚ï¸", "ðŸ™‡â€â™€ï¸", "ðŸ¤¦", "ðŸ¤¦â€â™‚ï¸", "ðŸ¤¦â€â™€ï¸", "ðŸ¤·", "ðŸ¤·â€â™‚ï¸", "ðŸ¤·â€â™€ï¸", "ðŸ§‘â€âš•ï¸", "ðŸ‘¨â€âš•ï¸", "ðŸ‘©â€âš•ï¸", "ðŸ§‘â€ðŸŽ“", "ðŸ‘¨â€ðŸŽ“", "ðŸ‘©â€ðŸŽ“", "ðŸ§‘â€ðŸ«", "ðŸ‘¨â€ðŸ«", "ðŸ‘©â€ðŸ«", "ðŸ§‘â€âš–ï¸", "ðŸ‘¨â€âš–ï¸", "ðŸ‘©â€âš–ï¸", "ðŸ§‘â€ðŸŒ¾", "ðŸ‘¨â€ðŸŒ¾", "ðŸ‘©â€ðŸŒ¾", "ðŸ§‘â€ðŸ³", "ðŸ‘¨â€ðŸ³", "ðŸ‘©â€ðŸ³", "ðŸ§‘â€ðŸ”§", "ðŸ‘¨â€ðŸ”§", "ðŸ‘©â€ðŸ”§", "ðŸ§‘â€ðŸ­", "ðŸ‘¨â€ðŸ­", "ðŸ‘©â€ðŸ­", "ðŸ§‘â€ðŸ’¼", "ðŸ‘¨â€ðŸ’¼", "ðŸ‘©â€ðŸ’¼", "ðŸ§‘â€ðŸ”¬", "ðŸ‘¨â€ðŸ”¬", "ðŸ‘©â€ðŸ”¬", "ðŸ§‘â€ðŸ’»", "ðŸ‘¨â€ðŸ’»", "ðŸ‘©â€ðŸ’»", "ðŸ§‘â€ðŸŽ¤", "ðŸ‘¨â€ðŸŽ¤", "ðŸ‘©â€ðŸŽ¤", "ðŸ§‘â€ðŸŽ¨", "ðŸ‘¨â€ðŸŽ¨", "ðŸ‘©â€ðŸŽ¨", "ðŸ§‘â€âœˆï¸", "ðŸ‘¨â€âœˆï¸", "ðŸ‘©â€âœˆï¸", "ðŸ§‘â€ðŸš€", "ðŸ‘¨â€ðŸš€", "ðŸ‘©â€ðŸš€", "ðŸ§‘â€ðŸš’", "ðŸ‘¨â€ðŸš’", "ðŸ‘©â€ðŸš’", "ðŸ‘®", "ðŸ‘®â€â™‚ï¸", "ðŸ‘®â€â™€ï¸", "ðŸ•µ", "ðŸ•µâ€â™‚ï¸", "ðŸ•µâ€â™€ï¸", "ðŸ’‚", "ðŸ’‚â€â™‚ï¸", "ðŸ’‚â€â™€ï¸", "ðŸ‘·", "ðŸ‘·â€â™‚ï¸", "ðŸ‘·â€â™€ï¸", "ðŸ¤´", "ðŸ‘¸", "ðŸ‘³", "ðŸ‘³â€â™‚ï¸", "ðŸ‘³â€â™€ï¸", "ðŸ‘²", "ðŸ§•", "ðŸ¤µ", "ðŸ¤µâ€â™‚ï¸", "ðŸ¤µâ€â™€ï¸", "ðŸ‘°", "ðŸ‘°â€â™‚ï¸", "ðŸ‘°â€â™€ï¸", "ðŸ¤°", "ðŸ¤±", "ðŸ‘©â€ðŸ¼", "ðŸ‘¨â€ðŸ¼", "ðŸ§‘â€ðŸ¼", "ðŸ‘¼", "ðŸŽ…", "ðŸ¤¶", "ðŸ§‘â€ðŸŽ„", "ðŸ¦¸", "ðŸ¦¸â€â™‚ï¸", "ðŸ¦¸â€â™€ï¸", "ðŸ¦¹", "ðŸ¦¹â€â™‚ï¸", "ðŸ¦¹â€â™€ï¸", "ðŸ§™", "ðŸ§™â€â™‚ï¸", "ðŸ§™â€â™€ï¸", "ðŸ§š", "ðŸ§šâ€â™‚ï¸", "ðŸ§šâ€â™€ï¸", "ðŸ§›", "ðŸ§›â€â™‚ï¸", "ðŸ§›â€â™€ï¸", "ðŸ§œ", "ðŸ§œâ€â™‚ï¸", "ðŸ§œâ€â™€ï¸", "ðŸ§", "ðŸ§â€â™‚ï¸", "ðŸ§â€â™€ï¸", "ðŸ§ž", "ðŸ§žâ€â™‚ï¸", "ðŸ§žâ€â™€ï¸", "ðŸ§Ÿ", "ðŸ§Ÿâ€â™‚ï¸", "ðŸ§Ÿâ€â™€ï¸", "ðŸ’†", "ðŸ’†â€â™‚ï¸", "ðŸ’†â€â™€ï¸", "ðŸ’‡", "ðŸ’‡â€â™‚ï¸", "ðŸ’‡â€â™€ï¸", "ðŸš¶", "ðŸš¶â€â™‚ï¸", "ðŸš¶â€â™€ï¸", "ðŸ§", "ðŸ§â€â™‚ï¸", "ðŸ§â€â™€ï¸", "ðŸ§Ž", "ðŸ§Žâ€â™‚ï¸", "ðŸ§Žâ€â™€ï¸", "ðŸ§‘â€ðŸ¦¯", "ðŸ‘¨â€ðŸ¦¯", "ðŸ‘©â€ðŸ¦¯", "ðŸ§‘â€ðŸ¦¼", "ðŸ‘¨â€ðŸ¦¼", "ðŸ‘©â€ðŸ¦¼", "ðŸ§‘â€ðŸ¦½", "ðŸ‘¨â€ðŸ¦½", "ðŸ‘©â€ðŸ¦½", "ðŸƒ", "ðŸƒâ€â™‚ï¸", "ðŸƒâ€â™€ï¸", "ðŸ’ƒ", "ðŸ•º", "ðŸ•´", "ðŸ‘¯", "ðŸ‘¯â€â™‚ï¸", "ðŸ‘¯â€â™€ï¸", "ðŸ§–", "ðŸ§–â€â™‚ï¸", "ðŸ§–â€â™€ï¸", "ðŸ§—", "ðŸ§—â€â™‚ï¸", "ðŸ§—â€â™€ï¸", "ðŸ¤º", "ðŸ‡", "â›·", "ðŸ‚", "ðŸŒ", "ðŸŒâ€â™‚ï¸", "ðŸŒâ€â™€ï¸", "ðŸ„", "ðŸ„â€â™‚ï¸", "ðŸ„â€â™€ï¸", "ðŸš£", "ðŸš£â€â™‚ï¸", "ðŸš£â€â™€ï¸", "ðŸŠ", "ðŸŠâ€â™‚ï¸", "ðŸŠâ€â™€ï¸", "â›¹", "â›¹â€â™‚ï¸", "â›¹â€â™€ï¸", "ðŸ‹", "ðŸ‹â€â™‚ï¸", "ðŸ‹â€â™€ï¸", "ðŸš´", "ðŸš´â€â™‚ï¸", "ðŸš´â€â™€ï¸", "ðŸšµ", "ðŸšµâ€â™‚ï¸", "ðŸšµâ€â™€ï¸", "ðŸ¤¸", "ðŸ¤¸â€â™‚ï¸", "ðŸ¤¸â€â™€ï¸", "ðŸ¤¼", "ðŸ¤¼â€â™‚ï¸", "ðŸ¤¼â€â™€ï¸", "ðŸ¤½", "ðŸ¤½â€â™‚ï¸", "ðŸ¤½â€â™€ï¸", "ðŸ¤¾", "ðŸ¤¾â€â™‚ï¸", "ðŸ¤¾â€â™€ï¸", "ðŸ¤¹", "ðŸ¤¹â€â™‚ï¸", "ðŸ¤¹â€â™€ï¸", "ðŸ§˜", "ðŸ§˜â€â™‚ï¸", "ðŸ§˜â€â™€ï¸", "ðŸ›€", "ðŸ›Œ", "ðŸ“„", "ðŸ“", "ðŸ“‚", "ðŸ’¼", "ðŸ“", "ðŸ—“", "ðŸ“…", "ðŸ“‡", "ðŸ“‰", "ðŸ“ˆ", "ðŸ“Š", "ðŸ“‹", "ðŸ“Œ", "ðŸ“", "ðŸ“Ž", "ðŸ“", "ðŸ“", "âœ‚ï¸", "ðŸ—‚", "ðŸ—ƒ", "ðŸ—„", "ðŸ—‘", "ðŸ”’", "ðŸ”“", "ðŸ”", "ðŸ”", "ðŸ”‘", "ðŸ—", "ðŸ”¨", "ðŸª“", "â›", "ðŸ”§", "ðŸ”©", "ðŸ§±", "âš™ï¸", "ðŸ—œ", "âš–ï¸", "ðŸ”—", "â›“", "ðŸ§°", "ðŸ§²", "ðŸªœ", "ðŸ©¸", "ðŸ’‰", "ðŸ’Š", "ðŸ©¹", "ðŸ©º", "ðŸ”­", "ðŸ”¬", "ðŸ¦ ", "ðŸ§¬", "ðŸ§ª", "ðŸ§«", "ðŸ§¹", "ðŸ§º", "ðŸ§»", "ðŸš½", "ðŸš°", "ðŸš¿", "ðŸ›", "ðŸ§¼", "ðŸª¥", "ðŸª’", "ðŸ§½", "ðŸª£", "ðŸ§´", "ðŸªž", "ðŸªŸ", "ðŸ›", "ðŸ›‹", "ðŸª‘", "ðŸšª", "ðŸ›Ž", "ðŸ–¼", "ðŸ§­", "ðŸ—º", "â›±", "ðŸ—¿", "ðŸ›", "ðŸ›’", "ðŸ‘“", "ðŸ•¶", "ðŸ¥½", "ðŸ¥¼", "ðŸ¦º", "ðŸ‘”", "ðŸ‘•", "ðŸ‘–", "ðŸ§£", "ðŸ§¤", "ðŸ§¥", "ðŸ§¦", "ðŸ‘—", "ðŸ‘˜", "ðŸ¥»", "ðŸ©±", "ðŸ©²", "ðŸ©³", "ðŸ‘™", "ðŸ‘š", "ðŸ‘›", "ðŸ‘œ", "ðŸ‘", "ðŸŽ’", "ðŸŽ’", "ðŸ‘ž", "ðŸ‘Ÿ", "ðŸ¥¾", "ðŸ¥¿", "ðŸ‘ ", "ðŸ‘¡", "ðŸ©°", "ðŸ‘¢", "ðŸ‘‘", "ðŸ‘’", "ðŸŽ©", "ðŸŽ“", "ðŸ§¢", "â›‘", "ðŸª–", "ðŸ’„", "ðŸ’", "ðŸ’Ž", "ðŸ”‡", "ðŸ”ˆ", "ðŸ”‰", "ðŸ”Š", "ðŸ“¢", "ðŸ“£", "ðŸ“¯", "ðŸ””", "ðŸ”•", "ðŸŽ¼", "ðŸŽµ", "ðŸŽ¶", "ðŸŽ™", "ðŸŽš", "ðŸŽ›", "ðŸŽ¤", "ðŸŽ§", "ðŸ“»", "ðŸŽ·", "ðŸª—", "ðŸŽ¸", "ðŸŽ¹", "ðŸŽº", "ðŸŽ»", "ðŸª•", "ðŸ¥", "ðŸ¥", "ðŸ“±", "ðŸ“²", "â˜Žï¸", "ðŸ“ž", "ðŸ“Ÿ", "ðŸ“ ", "ðŸ”‹", "ðŸ”Œ", "ðŸ’»", "ðŸ–¥", "ðŸ–¨", "âŒ¨ï¸", "ðŸ–±", "ðŸ–²", "ðŸ’½", "ðŸ’¾", "ðŸ’¿", "ðŸ“€", "ðŸ§®", "ðŸŽ¥", "ðŸŽž", "ðŸ“½", "ðŸŽ¬", "ðŸ“º", "ðŸ“·", "ðŸ“¸", "ðŸ“¹", "ðŸ“¼", "ðŸ”", "ðŸ”Ž", "ðŸ•¯", "ðŸ’¡", "ðŸ”¦", "ðŸ®", "ðŸª”", "ðŸ“”", "ðŸ“•", "ðŸ“–", "ðŸ“—", "ðŸ“˜", "ðŸ“™", "ðŸ“š", "ðŸ““", "ðŸ“’", "ðŸ“ƒ", "ðŸ“œ", "ðŸ“„", "ðŸ“°", "ðŸ—ž", "ðŸ“‘", "ðŸ”–", "ðŸ·", "ðŸ’°", "ðŸª™", "ðŸ’´", "ðŸ’µ", "ðŸ’¶", "ðŸ’·", "ðŸ’¸", "ðŸ’³", "ðŸ§¾", "âœ‰ï¸", "âœ‰ï¸", "ðŸ“§", "ðŸ“¨", "ðŸ“©", "ðŸ“¤", "ðŸ“¥", "ðŸ“¦", "ðŸ“«", "ðŸ“ª", "ðŸ“¬", "ðŸ“­", "ðŸ“®", "ðŸ—³", "âœï¸", "âœ’ï¸", "ðŸ–‹", "ðŸ–Š", "ðŸ–Œ", "ðŸ–", "ðŸ“", "ðŸ’¼", "ðŸ“", "ðŸ“‚", "ðŸ—‚", "ðŸ“…", "ðŸ“†", "ðŸ—’", "ðŸ—“", "ðŸ“‡", "ðŸ“ˆ", "ðŸ“‰", "ðŸ“Š", "ðŸ“‹", "ðŸ“Œ", "ðŸ“", "ðŸ“Ž", "ðŸ–‡", "ðŸ“", "ðŸ“", "âœ‚ï¸", "ðŸ—ƒ", "ðŸ—„", "ðŸ—‘", "ðŸ”’", "ðŸ”“", "ðŸ”", "ðŸ”", "ðŸ”‘", "ðŸ—", "ðŸ”¨", "ðŸª“", "â›", "ðŸ”§", "ðŸ”©", "ðŸ§±", "âš™ï¸", "ðŸ—œ", "âš–ï¸", "ðŸ”—", "â›“", "ðŸ§°", "ðŸ§²", "ðŸªœ", "âš—ï¸", "ðŸ”­", "ðŸ”¬", "ðŸ•³", "ðŸ©¹", "ðŸ©º", "ðŸ’Š", "ðŸ’‰", "ðŸ©¸", "ðŸ§¬", "ðŸ¦ ", "ðŸ§«", "ðŸ§ª", "ðŸŒ¡", "ðŸ§¹", "ðŸª ", "ðŸ§º", "ðŸ§»", "ðŸš½", "ðŸš°", "ðŸš¿", "ðŸ›", "ðŸ›€", "ðŸ§¼", "ðŸª¥", "ðŸª’", "ðŸ§½", "ðŸª£", "ðŸ§´", "ðŸ›Ž", "ðŸ”‘", "ðŸ—", "ðŸšª", "ðŸª‘", "ðŸ›‹", "ðŸ›", "ðŸ›Œ", "ðŸ§¸", "ðŸª†", "ðŸ–¼", "ðŸªž", "ðŸªŸ", "ðŸ›", "ðŸ›’", "ðŸŽ", "ðŸŽˆ", "ðŸŽ", "ðŸŽ€", "ðŸª„", "ðŸª…", "ðŸŽŠ", "ðŸŽ‰", "ðŸŽŽ", "ðŸ®", "ðŸŽ", "ðŸ§§", "âœ‰ï¸", "ðŸ“©", "ðŸ“¨", "ðŸ“§", "ðŸ’Œ", "ðŸ“¥", "ðŸ“¤", "ðŸ“¦", "ðŸ·", "ðŸª§", "ðŸ“ª", "ðŸ“«", "ðŸ“¬", "ðŸ“­", "ðŸ“®", "ðŸ“¯", "ðŸ“œ", "ðŸ“ƒ", "ðŸ“„", "ðŸ“‘", "ðŸ§¾", "ðŸ“Š", "ðŸ“ˆ", "ðŸ“‰", "ðŸ—’", "ðŸ—“", "ðŸ“†", "ðŸ“…", "ðŸ—‘", "ðŸ“‡", "ðŸ—ƒ", "ðŸ—³", "ðŸ—„", "ðŸ“‹", "ðŸ“", "ðŸ“‚", "ðŸ—‚", "ðŸ—ž", "ðŸ“°", "ðŸ““", "ðŸ“”", "ðŸ“’", "ðŸ“•", "ðŸ“—", "ðŸ“˜", "ðŸ“™", "ðŸ“š", "ðŸ“–", "ðŸ”–", "ðŸ”—", "ðŸ“Ž", "ðŸ–‡", "ðŸ“", "ðŸ“", "ðŸ§®", "ðŸ“Œ", "ðŸ“", "âœ‚ï¸", "ðŸ–Š", "ðŸ–‹", "âœ’ï¸", "ðŸ–Œ", "ðŸ–", "ðŸ“", "âœï¸", "ðŸ”", "ðŸ”Ž", "ðŸ”", "ðŸ”", "ðŸ”’", "ðŸ”“"];

  const generateId = () => Math.random().toString(36).substr(2, 9);

  // Get next tab color by cycling through COLORS array
  const getNextTabColor = (existingTabs) => {
      if (!existingTabs || existingTabs.length === 0) return COLORS[0].name;
      const lastTabColor = existingTabs[existingTabs.length - 1].color;
      const currentIndex = COLORS.findIndex(c => c.name === lastTabColor);
      const nextIndex = (currentIndex + 1) % COLORS.length;
      return COLORS[nextIndex].name;
  };

  /** Pure: resolve notebook/tab/page from data by ids. Returns { notebook, tab, page }. */
  const getActiveContext = (data, notebookId, tabId, pageId) => {
      const notebook = data.notebooks?.find(n => n.id === notebookId) ?? null;
      const tab = notebook?.tabs?.find(t => t.id === tabId) ?? null;
      const page = tab?.pages?.find(p => p.id === pageId) ?? null;
      return { notebook, tab, page };
  };

  /** Pure: immutable update of a single page in data. updater(page) => newPage. */
  const updatePageInData = (data, { notebookId, tabId, pageId }, updater) => {
      return {
          ...data,
          notebooks: data.notebooks.map(nb =>
              nb.id !== notebookId ? nb : {
                  ...nb,
                  tabs: nb.tabs.map(tab =>
                      tab.id !== tabId ? tab : {
                          ...tab,
                          pages: tab.pages.map(p =>
                              p.id !== pageId ? p : updater(p)
                          )
                      }
                  )
              }
          )
      };
  };

  /** Pure: drop indicator Tailwind classes for block DnD. */
  const getDropIndicatorClass = (position) => {
      switch (position) {
          case 'top': return 'border-t-4 border-blue-500 pt-2';
          case 'bottom': return 'border-b-4 border-blue-500 pb-2';
          case 'left': return 'border-l-4 border-blue-500 pl-2';
          case 'right': return 'border-r-4 border-blue-500 pr-2';
          default: return '';
      }
  };

  const INITIAL_DATA = {
    notebooks: [
      {
        id: 'nb1', name: 'My First Notebook', icon: 'ðŸ““', activeTabId: 'tab1',
        tabs: [
          {
            id: 'tab1', name: 'General', icon: 'ðŸ“‹', color: 'blue', activePageId: 'page1',
            pages: [
              {
                id: 'page1', 
                name: 'Welcome', 
                createdAt: Date.now(),
                icon: 'ðŸ‘‹',
                cover: 'https://images.unsplash.com/photo-1579546929518-9e396f3cc809?auto=format&fit=crop&w=1200&q=80',
                rows: [
                  {
                    id: 'row1', columns: [
                      {
                        id: 'col1', blocks: [
                          { id: 'blk1', type: 'h1', content: 'Welcome to your new Note App!' },
                          { id: 'blk2', type: 'text', content: 'Try <b>bolding</b> or <i>italicizing</i> this text using standard keyboard shortcuts.' },
                          { id: 'blk3', type: 'text', content: 'Type / to see available commands like /h1, /todo, /img, etc.' },
                          { id: 'blk4', type: 'todo', content: 'Try checking this item', checked: false }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  };

  function getYouTubeID(url) {
      if (!url) return '';
      const regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?v=)|(shorts\/))([^#&?]*).*/;
      const match = url.match(regExp);
      return (match && match[8].length === 11) ? match[8] : '';
  }

  // --- Components ---

  const ImageLightbox = ({ src, onClose }) => {
      const [scale, setScale] = useState(1);
      return (
          <div className="fixed inset-0 z-[10001] bg-black/95 flex flex-col animate-fade-in backdrop-blur-sm">
              <div className="flex justify-end p-6">
                  <button onClick={onClose} className="text-white/70 hover:text-white transition-colors bg-white/10 hover:bg-white/20 p-2 rounded-full"><X size={24} /></button>
              </div>
              <div className="flex-1 flex items-center justify-center overflow-hidden p-8" onClick={onClose}>
                  <img src={src} alt="Full screen" className="max-w-full max-h-full object-contain transition-transform duration-300 ease-in-out"
                      style={{ transform: `scale(${scale})`, cursor: scale > 1 ? 'zoom-out' : 'zoom-in' }}
                      onClick={(e) => { e.stopPropagation(); setScale(prev => prev === 1 ? 2.5 : 1); }} />
              </div>
          </div>
      )
  }

  const ContentBlock = memo(({ html, tagName, className, placeholder, onChange, onInsertBelow, onInsertTextBelow, onExitList, blockId, autoFocusId, onFocus, onConvert, onDelete, isLastBlock }) => {
      const contentEditableRef = useRef(null);
      const isLocked = useRef(false);
      const [slashMenu, setSlashMenu] = useState({ open: false, filter: '', selectedIndex: 0, position: { top: 0, left: 0 } });

      const processHtml = (rawHtml, tag) => {
          if ((tag === 'ul' || tag === 'ol')) {
              if (!rawHtml || rawHtml.trim() === '' || rawHtml === '<br>') return '<li></li>';
              if (!rawHtml.includes('<li>')) return `<li>${rawHtml}</li>`;
          }
          return rawHtml;
      };

      const safeHtml = processHtml(html, tagName);

      const filteredCommands = slashMenu.open ? SLASH_COMMANDS.filter(cmd =>
          cmd.aliases.some(alias => alias.startsWith(slashMenu.filter.toLowerCase())) ||
          cmd.label.toLowerCase().includes(slashMenu.filter.toLowerCase())
      ) : [];

      useEffect(() => {
          if (!contentEditableRef.current) return;
          const el = contentEditableRef.current;
          if (!isLocked.current && el.innerHTML !== safeHtml) {
              el.innerHTML = safeHtml;
          }
      }, [safeHtml]);

      useEffect(() => {
          if (!contentEditableRef.current) return;
          contentEditableRef.current.innerHTML = processHtml(html, tagName);
      }, [blockId]);

      useLayoutEffect(() => {
          if (autoFocusId !== blockId || !contentEditableRef.current) return;
          const el = contentEditableRef.current;
          el.focus();
          const range = document.createRange();
          const sel = window.getSelection();
          range.selectNodeContents(el);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
      }, [autoFocusId, blockId]);

      const getCaretPosition = () => {
          const sel = window.getSelection();
          if (sel.rangeCount > 0) {
              const range = sel.getRangeAt(0).cloneRange();
              range.collapse(true);
              const rect = range.getClientRects()[0];
              if (rect) return { top: rect.bottom + 5, left: rect.left };
          }
          if (contentEditableRef.current) {
              const rect = contentEditableRef.current.getBoundingClientRect();
              return { top: rect.bottom + 5, left: rect.left };
          }
          return { top: 0, left: 0 };
      };

      const selectSlashCommand = (cmd) => {
          setSlashMenu({ open: false, filter: '', selectedIndex: 0, position: { top: 0, left: 0 } });
          // Clear the contentEditable content before converting to ensure slash command text is removed
          if (contentEditableRef.current) {
              contentEditableRef.current.innerHTML = '';
          }
          onConvert(cmd.type);
      };

      const handleInput = (e) => {
          isLocked.current = true;
          const text = e.currentTarget.innerText;
          onChange(e.currentTarget.innerHTML);
          
          // Check for slash command trigger
          if (text.startsWith('/')) {
              const filter = text.substring(1);
              const position = getCaretPosition();
              setSlashMenu({ open: true, filter, selectedIndex: 0, position });
          } else {
              if (slashMenu.open) setSlashMenu({ open: false, filter: '', selectedIndex: 0, position: { top: 0, left: 0 } });
          }
      };
      
      const handleBlur = () => { 
          isLocked.current = false;
          // Delay closing to allow click on menu items
          setTimeout(() => setSlashMenu(prev => ({ ...prev, open: false })), 150);
      };
      const handleFocus = () => { if (onFocus) onFocus(); }

      const handleKeyDown = (e) => {
          // Handle slash menu navigation
          if (slashMenu.open && filteredCommands.length > 0) {
              if (e.key === 'ArrowDown') {
                  e.preventDefault();
                  setSlashMenu(prev => ({ ...prev, selectedIndex: (prev.selectedIndex + 1) % filteredCommands.length }));
                  return;
              }
              if (e.key === 'ArrowUp') {
                  e.preventDefault();
                  setSlashMenu(prev => ({ ...prev, selectedIndex: prev.selectedIndex === 0 ? filteredCommands.length - 1 : prev.selectedIndex - 1 }));
                  return;
              }
              if (e.key === 'Enter' || e.key === 'Tab') {
                  e.preventDefault();
                  selectSlashCommand(filteredCommands[slashMenu.selectedIndex]);
                  return;
              }
              if (e.key === 'Escape') {
                  e.preventDefault();
                  setSlashMenu({ open: false, filter: '', selectedIndex: 0, position: { top: 0, left: 0 } });
                  return;
              }
          }

          if (e.key === 'Enter') {
              // Slash commands (fallback for when menu is closed but text starts with /)
              if (contentEditableRef.current) {
                  const text = contentEditableRef.current.innerText.trim();
                  if (text.startsWith('/')) {
                      const cmd = text.substring(1).toLowerCase();
                      const matchedCmd = SLASH_COMMANDS.find(c => c.aliases.includes(cmd));
                      if (matchedCmd) {
                          e.preventDefault();
                          // Clear the contentEditable content before converting
                          contentEditableRef.current.innerHTML = '';
                          onConvert(matchedCmd.type);
                          return;
                      }
                  }
              }

              // Standard behavior for text blocks and lists
              if (!e.shiftKey) {
                 if (tagName !== 'ul' && tagName !== 'ol') {
                     // For regular text blocks, Enter creates a new block below
                     // But if we have onExitList and content is empty, exit the list instead
                     if (onExitList && contentEditableRef.current) {
                         const text = contentEditableRef.current.innerText.trim();
                         if (text === '') {
                             e.preventDefault();
                             onExitList();
                             return;
                         }
                     }
                     e.preventDefault();
                     onInsertBelow();
                     return;
                 }
                 // For ul/ol lists, check if we should exit the list (double-enter on blank last item)
                 if (tagName === 'ul' || tagName === 'ol') {
                     const selection = window.getSelection();
                     if (selection.rangeCount > 0) {
                         // Find the current li element
                         let currentNode = selection.anchorNode;
                         let currentLi = null;
                         while (currentNode && currentNode !== contentEditableRef.current) {
                             if (currentNode.nodeName === 'LI') {
                                 currentLi = currentNode;
                                 break;
                             }
                             currentNode = currentNode.parentNode;
                         }
                         
                         if (currentLi) {
                             const liText = currentLi.innerText.trim();
                             const allLis = contentEditableRef.current.querySelectorAll('li');
                             const isLastLi = allLis.length > 0 && allLis[allLis.length - 1] === currentLi;
                             
                             // If current li is blank and is the last one, exit the list
                             if (liText === '' && isLastLi) {
                                 e.preventDefault();
                                 // Remove the blank li
                                 currentLi.remove();
                                 // Update the content
                                 onChange(contentEditableRef.current.innerHTML);
                                 // Create a new text block below
                                 onInsertBelow();
                                 return;
                             }
                         }
                     }
                 }
              }
          }

          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
              e.preventDefault();
              // Use onInsertTextBelow if available (for todo blocks), otherwise onInsertBelow
              if (onInsertTextBelow) {
                  onInsertTextBelow();
              } else {
                  onInsertBelow();
              }
              return;
          }
          if (e.key === 'Tab') {
              e.preventDefault();
              if (tagName === 'ul' || tagName === 'ol') document.execCommand(e.shiftKey ? 'outdent' : 'indent', false, null);
          }
          if ((e.ctrlKey || e.metaKey)) {
              switch(e.key.toLowerCase()) {
                  case 'b': e.preventDefault(); document.execCommand('bold', false, null); break;
                  case 'i': e.preventDefault(); document.execCommand('italic', false, null); break;
                  case 'u': e.preventDefault(); document.execCommand('underline', false, null); break;
                  default: break;
              }
          }
          
          // Handle Backspace in empty blocks
          if (e.key === 'Backspace') {
              const text = contentEditableRef.current?.innerText?.trim() || '';
              if (text === '') {
                  // Empty block
                  if (tagName === 'div') {
                      // Text block - delete if not last block
                      if (!isLastBlock && onDelete) {
                          e.preventDefault();
                          onDelete();
                      }
                  } else {
                      // Non-text block (h1, h2, h3, h4, ul, ol) - convert to text
                      e.preventDefault();
                      onConvert('text');
                  }
              }
          }
      };

      const Tag = tagName;
      return (
          <>
              <Tag
                  ref={contentEditableRef}
                  className={tagName === 'ul' || tagName === 'ol' ?
                      `outline-none pl-5 ml-1 cursor-text list-outside ${className} ${tagName === 'ul' ? 'list-disc' : 'list-decimal'}` :
                      `outline-none empty:before:content-[attr(placeholder)] empty:before:text-gray-300 cursor-text ${className}`
                  }
                  contentEditable
                  suppressContentEditableWarning
                  placeholder={placeholder}
                  onInput={handleInput}
                  onKeyDown={handleKeyDown}
                  onBlur={handleBlur}
                  onFocus={handleFocus}
              />
              {slashMenu.open && filteredCommands.length > 0 && (
                  <div 
                      className="fixed z-[10000] bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 rounded-lg shadow-xl py-1 min-w-[220px] max-h-[300px] overflow-y-auto animate-fade-in"
                      style={{ top: slashMenu.position.top, left: slashMenu.position.left }}
                  >
                      {filteredCommands.map((cmd, index) => (
                          <div
                              key={cmd.cmd}
                              className={`px-3 py-2 cursor-pointer flex items-center gap-3 ${index === slashMenu.selectedIndex ? 'bg-blue-50 dark:bg-blue-900/30' : 'hover:bg-gray-50 dark:hover:bg-gray-700'}`}
                              onMouseDown={(e) => { e.preventDefault(); selectSlashCommand(cmd); }}
                              onMouseEnter={() => setSlashMenu(prev => ({ ...prev, selectedIndex: index }))}
                          >
                              <span className="text-gray-400 font-mono text-sm">/{cmd.cmd}</span>
                              <div className="flex-1">
                                  <div className="font-medium text-sm dark:text-white">{cmd.label}</div>
                                  <div className="text-xs text-gray-400">{cmd.desc}</div>
                              </div>
                          </div>
                      ))}
                  </div>
              )}
          </>
      );
  });

  const BlockComponent = memo(({ block, rowId, colId, onUpdate, onDelete, onInsertAfter, autoFocusId, onRequestFocus, onDragStart, onDragOver, onDrop, dropTarget, isSelected, onHandleClick, onFocus, isLastBlock }) => {
      const isTarget = dropTarget && dropTarget.blockId === block.id;
      const indicatorStyle = isTarget ? getDropIndicatorClass(dropTarget.position) : '';

      const [showLightbox, setShowLightbox] = useState(false);
      const bgClass = block.backgroundColor ? BG_COLORS[block.backgroundColor] : '';
      // Only add bg-blue-50/50 if there's no background color, so selection doesn't obscure block colors
      const borderClass = isSelected 
          ? `ring-2 ring-blue-400 ring-offset-2 ${!block.backgroundColor ? 'bg-blue-50/50' : ''}` 
          : 'hover:bg-gray-50';

      const handleConvert = (newType) => {
          const isMedia = ['image', 'video', 'link'].includes(newType);
          onUpdate(block.id, { type: newType, content: isMedia ? '' : '', url: '' });
          if (newType === 'divider') {
              onInsertAfter(block.id, 'text');
          } else if (onRequestFocus) {
              onRequestFocus(block.id);
          }
      };

      const handleMediaKeyDown = (e) => {
          if (e.key === 'Enter') {
              if (e.ctrlKey || e.metaKey) {
                  e.preventDefault();
                  onInsertAfter(block.id, 'text');
              } else {
                  e.target.blur();
              }
          }
      };

      const renderTextContent = () => {
          const props = {
              html: block.content,
              onChange: (content) => onUpdate(block.id, { content }),
              onInsertBelow: () => onInsertAfter(block.id, 'text'),
              onInsertTextBelow: () => onInsertAfter(block.id, 'text'),
              blockId: block.id,
              autoFocusId,
              onFocus,
              onConvert: handleConvert,
              onDelete: () => onDelete(block.id),
              isLastBlock,
              placeholder: "Type '/' for commands"
          };

          switch (block.type) {
              case 'h1': return <ContentBlock tagName="h1" className="text-3xl font-bold mb-4" {...props} placeholder="Heading 1" />;
              case 'h2': return <ContentBlock tagName="h2" className="text-2xl font-bold mb-3 border-b border-gray-100 pb-1" {...props} placeholder="Heading 2" />;
              case 'h3': return <ContentBlock tagName="h3" className="text-xl font-bold mb-2" {...props} placeholder="Heading 3" />;
              case 'h4': return <ContentBlock tagName="h4" className="text-lg font-semibold mb-2 text-gray-600" {...props} placeholder="Heading 4" />;
              case 'ul': return <ContentBlock tagName="ul" className="mb-2" {...props} />;
              case 'ol': return <ContentBlock tagName="ol" className="mb-2" {...props} />;
              default: return <ContentBlock tagName="div" className="leading-relaxed min-h-[1.5em]" {...props} />;
          }
      };

      return (
          <>
              <div 
                  draggable
                  onDragStart={(e) => onDragStart(e, block, rowId, colId)}
                  onDragOver={(e) => onDragOver(e, block.id, rowId, colId)}
                  onDrop={onDrop}
                  className={`group relative flex gap-2 items-start p-1 rounded transition-all ${indicatorStyle} ${bgClass} ${borderClass}`}
              >
                  <div className="mt-1 cursor-grab opacity-0 group-hover:opacity-50 hover:!opacity-100 active:cursor-grabbing text-gray-400 block-handle" onClick={(e) => onHandleClick(e, block.id)}>
                      <GripVertical size={16} />
                  </div>
                  <div className="flex-1 min-w-0">
                      {['text', 'h1', 'h2', 'h3', 'h4', 'ul', 'ol'].includes(block.type) && renderTextContent()}
                      
                      {block.type === 'todo' && (
                          <div className="flex items-start gap-2 mb-1">
                              <div className="pt-1 select-none" contentEditable={false}>
                                  <input type="checkbox" checked={block.checked || false} onChange={(e) => onUpdate(block.id, { checked: e.target.checked })} className="w-4 h-4 cursor-pointer accent-blue-500 rounded border-gray-300" />
                              </div>
                              <div className={`flex-1 ${block.checked ? 'line-through text-gray-400' : ''}`}>
                                  <ContentBlock tagName="div" className="leading-relaxed min-h-[1.5em]" html={block.content} onChange={(content) => onUpdate(block.id, { content })} onInsertBelow={() => onInsertAfter(block.id, 'todo')} onInsertTextBelow={() => onInsertAfter(block.id, 'text')} onExitList={() => handleConvert('text')} blockId={block.id} autoFocusId={autoFocusId} onFocus={onFocus} onConvert={handleConvert} onDelete={() => onDelete(block.id)} isLastBlock={isLastBlock} placeholder="To-do item" />
                              </div>
                          </div>
                      )}

                      {block.type === 'image' && (
                          <div className="space-y-2">
                              {block.url ? (
                                  <div className="group/image relative">
                                      <img src={block.url} alt="Content" className="max-w-full rounded shadow-sm max-h-[400px] object-cover hover:scale-[1.02] cursor-zoom-in transition-transform" onClick={() => setShowLightbox(true)} />
                                  </div>
                              ) : (
                                  <div className="bg-gray-100 p-4 rounded text-center border-2 border-dashed border-gray-300">
                                      <input className="w-full p-2 border rounded text-xs mb-2" placeholder="Paste image URL..." onBlur={(e) => onUpdate(block.id, { url: e.target.value })} onKeyDown={handleMediaKeyDown} autoFocus/>
                                  </div>
                              )}
                          </div>
                      )}
                      {block.type === 'video' && (
                          <div className="space-y-2">
                              {block.url ? (
                                  <div className="aspect-video w-full rounded overflow-hidden shadow-sm bg-black">
                                      <iframe width="100%" height="100%" src={`https://www.youtube.com/embed/${getYouTubeID(block.url)}`} frameBorder="0" allowFullScreen></iframe>
                                  </div>
                              ) : (
                                  <div className="bg-gray-100 p-4 rounded text-center border-2 border-dashed border-gray-300">
                                      <input className="w-full p-2 border rounded text-xs mb-2" placeholder="Paste YouTube URL..." onBlur={(e) => onUpdate(block.id, { url: e.target.value })} onKeyDown={handleMediaKeyDown} autoFocus/>
                                  </div>
                              )}
                          </div>
                      )}
                      {block.type === 'link' && (
                          <div className="p-3 bg-blue-50 rounded border border-blue-100 flex items-center gap-3">
                              <LinkIcon size={20} className="text-blue-500"/>
                              <div className="flex-1 min-w-0">
                                  <input className="w-full bg-transparent font-medium text-blue-700 outline-none" value={block.content} onChange={(e) => onUpdate(block.id, { content: e.target.value })} onKeyDown={handleMediaKeyDown} placeholder="Link Title" autoFocus/>
                                  <input className="w-full bg-transparent text-xs text-blue-400 outline-none" value={block.url || ''} onChange={(e) => onUpdate(block.id, { url: e.target.value })} placeholder="https://example.com" />
                              </div>
                              {block.url && <a href={block.url} target="_blank" className="p-2 hover:bg-blue-100 rounded text-blue-600"><ChevronRight size={16}/></a>}
                          </div>
                      )}
                      {block.type === 'divider' && <div className="py-2"><hr className="border-t-2 border-gray-200" /></div>}
                      {block.type === 'gdoc' && (
                          <div className="space-y-2">
                              {block.driveFileId ? (
                                  <div className="border rounded overflow-hidden shadow-sm">
                                      {block.mimeType === 'application/vnd.google-apps.document' && (
                                          <iframe 
                                              src={`https://docs.google.com/document/d/${block.driveFileId}/preview`}
                                              className="w-full h-96 border-0"
                                              title="Google Doc"
                                          />
                                      )}
                                      {block.mimeType === 'application/vnd.google-apps.spreadsheet' && (
                                          <iframe 
                                              src={`https://docs.google.com/spreadsheets/d/${block.driveFileId}/preview`}
                                              className="w-full h-96 border-0"
                                              title="Google Sheet"
                                          />
                                      )}
                                      {block.mimeType === 'application/vnd.google-apps.presentation' && (
                                          <iframe 
                                              src={`https://docs.google.com/presentation/d/${block.driveFileId}/preview`}
                                              className="w-full h-96 border-0"
                                              title="Google Slide"
                                          />
                                      )}
                                      {block.webViewLink && (
                                          <div className="p-2 bg-gray-50 border-t flex items-center justify-between">
                                              <a href={block.webViewLink} target="_blank" rel="noopener noreferrer" className="text-sm text-blue-600 hover:underline">
                                                  Open in Google Drive
                                              </a>
                                              <button onClick={() => onUpdate(block.id, { driveFileId: null, webViewLink: null, mimeType: null })} className="text-xs text-gray-500 hover:text-red-600">
                                                  Remove
                                              </button>
                                          </div>
                                      )}
                                  </div>
                              ) : (
                                  <div className="bg-gray-100 p-4 rounded text-center border-2 border-dashed border-gray-300">
                                      {typeof GoogleAPI !== 'undefined' && isAuthenticated ? (
                                          <button 
                                              onClick={() => {
                                                  GoogleAPI.showDrivePicker((file) => {
                                                      onUpdate(block.id, {
                                                          driveFileId: file.id,
                                                          webViewLink: file.url,
                                                          mimeType: file.mimeType
                                                      });
                                                  });
                                              }}
                                              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
                                          >
                                              Select Google Drive File
                                          </button>
                                      ) : (
                                          <div className="text-sm text-gray-500">
                                              Sign in with Google to embed Drive files
                                          </div>
                                      )}
                                  </div>
                              )}
                          </div>
                      )}
                  </div>
              </div>
              {showLightbox && block.url && <ImageLightbox src={block.url} onClose={() => setShowLightbox(false)} />}
          </>
      );
  });

  // --- Canvas Component ---
  const getFormattedDate = () => {
    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const timeOptions = { hour: 'numeric', minute: 'numeric' };
    const now = new Date();
    return {
      date: now.toLocaleDateString('en-US', options),
      time: now.toLocaleTimeString('en-US', timeOptions)
    };
  };

  const SlashMenu = ({ x, y, onSelect, onClose }) => {
    const options = [
      { label: 'Heading 1', action: () => onSelect('formatBlock', 'H1') },
      { label: 'Heading 2', action: () => onSelect('formatBlock', 'H2') },
      { label: 'To-Do List', action: () => onSelect('insertHTML', '<input type="checkbox" style="margin-right:8px;vertical-align:middle;">&nbsp;') },
      { label: 'Bullet List', action: () => onSelect('insertUnorderedList') },
      { label: 'Numbered List', action: () => onSelect('insertOrderedList') },
      { label: 'Insert Date', action: () => onSelect('insertText', new Date().toLocaleDateString()) },
    ];

    return (
      <div 
        className="fixed bg-white shadow-lg border border-gray-200 rounded-lg py-1 z-[100] w-48 animate-fade-in"
        style={{ left: x, top: y + 20 }}
      >
        <div className="px-3 py-1 text-xs font-semibold text-gray-400 border-b mb-1">BASIC BLOCKS</div>
        {options.map((opt, i) => (
          <button
            key={i}
            className="w-full text-left px-3 py-1.5 hover:bg-purple-50 text-sm text-gray-700 flex items-center"
            onMouseDown={(e) => { e.preventDefault(); opt.action(); }}
          >
            {opt.label}
          </button>
        ))}
      </div>
    );
  };

  const ToolbarBtn = ({ icon, onClick, active, title }) => (
    <button 
      onClick={(e) => { e.stopPropagation(); onClick(); }}
      className={`p-1 rounded-md transition-colors ${active ? 'bg-purple-100 text-purple-700' : 'hover:bg-gray-100 text-gray-700'}`}
      title={title}
    >
      {icon}
    </button>
  );

  const UniversalContainer = ({ container, scale, isSelected, onSelect, onUpdate, onDragStart, onResizeStart, onDelete, onSlash }) => {
    const contentRef = useRef(null);

    useLayoutEffect(() => {
      if (container.type === 'text' && contentRef.current && contentRef.current.innerHTML !== container.content) {
         contentRef.current.innerHTML = container.content;
      }
    }, [container.content, container.type]);

    const handleInput = (e) => {
      if (contentRef.current) {
        const val = contentRef.current.innerHTML;
        if (val.trim() === '/') {
           const rect = contentRef.current.getBoundingClientRect();
           onSlash(rect.left, rect.bottom);
        }
        onUpdate({ content: val });
      }
    };

    const handleContentClick = (e) => {
      if (e.target.tagName === 'INPUT' && e.target.type === 'checkbox') {
        const checkbox = e.target;
        if (checkbox.checked) {
          checkbox.setAttribute('checked', 'true');
          const parent = checkbox.parentElement;
          const isSharedParent = parent.querySelectorAll('input[type="checkbox"]').length > 1;
          if (parent && parent !== contentRef.current && !isSharedParent) {
               parent.style.textDecoration = 'line-through';
               parent.style.color = '#9ca3af'; 
          }
        } else {
          checkbox.removeAttribute('checked');
          if (checkbox.parentElement && checkbox.parentElement !== contentRef.current) {
               checkbox.parentElement.style.textDecoration = 'none';
               checkbox.parentElement.style.color = 'inherit';
          }
        }
        if (contentRef.current) {
          onUpdate({ content: contentRef.current.innerHTML });
        }
      }
    };

    const handleKeyDown = (e) => {
       if (e.key === 'Tab') {
         e.preventDefault();
         document.execCommand(e.shiftKey ? 'outdent' : 'indent');
       }
       if (e.key === 'Enter') {
          const selection = window.getSelection();
          const anchorNode = selection.anchorNode;
          const parentBlock = anchorNode.nodeType === 3 ? anchorNode.parentNode : anchorNode;
          const currentLine = parentBlock.closest('div') || parentBlock;
          if (currentLine.innerHTML && currentLine.innerHTML.includes('type="checkbox"')) {
               e.preventDefault();
               document.execCommand('insertParagraph');
               document.execCommand('insertHTML', false, '<input type="checkbox" style="margin-right:8px;vertical-align:middle;">&nbsp;');
          }
       }
    };

    return (
      <div 
        id={`container-${container.id}`}
        className={`absolute group flex flex-col ${isSelected ? 'z-30' : 'z-20'}`}
        style={{ 
          left: container.x + 25000, 
          top: container.y + 25000, 
          width: container.width ? `${container.width}px` : 'fit-content',
          maxWidth: container.type === 'text' ? '600px' : 'none',
          minWidth: '100px'
        }}
        onClick={(e) => { e.stopPropagation(); onSelect(); }}
      >
        <div 
          className={`h-4 w-full bg-gray-50 border border-gray-200 border-b-0 rounded-t cursor-move flex items-center justify-center transition-opacity
            ${isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'}
          `}
          onMouseDown={onDragStart}
        >
          <GripHorizontal size={12} className="text-gray-400" />
        </div>

        <div className={`
          relative bg-white shadow-sm
          ${isSelected ? 'border border-gray-300 ring-1 ring-purple-500/20' : 'border border-transparent hover:border-gray-200'}
        `}>
           {isSelected && (
             <>
               <button onClick={(e) => {e.stopPropagation(); onDelete()}} className="absolute -right-2 -top-2 bg-white rounded-full p-1 shadow border hover:bg-red-50 text-gray-400 hover:text-red-500 z-50">
                 <X size={10} />
               </button>
               <div 
                 className="absolute top-0 right-[-6px] h-full w-4 cursor-ew-resize flex items-center justify-center z-40 opacity-0 hover:opacity-100"
                 onMouseDown={onResizeStart}
               >
                  <div className="w-1 h-8 bg-blue-300 rounded-full"/>
               </div>
             </>
           )}

           {container.type === 'text' ? (
             <div
               id={`editor-${container.id}`}
               ref={contentRef}
               contentEditable
               suppressContentEditableWarning
               className="outline-none px-3 py-2 min-h-[1em]"
               onInput={handleInput}
               onClick={handleContentClick}
               onKeyDown={handleKeyDown}
               onBlur={handleInput}
               style={{ cursor: 'text' }}
             />
           ) : (
             <div className="p-1">
               <img src={container.content} alt="Pasted" className="w-full h-auto pointer-events-none" />
             </div>
           )}
        </div>
      </div>
    );
  };

  const CanvasPageComponent = ({ page, onUpdate, saveToHistory, showNotification }) => {
    const canvasData = page.canvasData || { containers: [], paths: [], pageTitle: page.name || 'Untitled Page', transform: { x: 32, y: 32, scale: 1 } };
    
    // State
    const [containers, setContainers] = useState(canvasData.containers || []);
    const [paths, setPaths] = useState(canvasData.paths || []);
    const [pageTitle, setPageTitle] = useState(canvasData.pageTitle || page.name || 'Untitled Page');
    const [history, setHistory] = useState({ past: [], future: [] });
    const [appClipboard, setAppClipboard] = useState(null);
    const initialTransform = canvasData.transform || { x: 32, y: 32, scale: 1 };
    const [transform, setTransform] = useState(initialTransform);
    const [cursorPos, setCursorPos] = useState({ x: 0, y: 0 });
    const [tool, setTool] = useState('cursor');
    const [selectedId, setSelectedId] = useState(null);
    const [selectedType, setSelectedType] = useState(null);
    const [isSpacePressed, setIsSpacePressed] = useState(false);
    const [slashMenu, setSlashMenu] = useState(null);
    const [brushColor, setBrushColor] = useState('#000000');
    const [brushWidth, setBrushWidth] = useState(2);
    const [dragInfo, setDragInfo] = useState(null);
    const [resizeInfo, setResizeInfo] = useState(null);
    const [drawInfo, setDrawInfo] = useState(null);
    const canvasRef = useRef(null);
    const [currentDate] = useState(getFormattedDate());
    const [showIconPicker, setShowIconPicker] = useState(false);
    const iconPickerRef = useRef(null);

    // Initialize from page data when page changes
    useEffect(() => {
      const data = page.canvasData || {};
      setContainers(data.containers || []);
      setPaths(data.paths || []);
      // Sync pageTitle with page.name - use page.name as source of truth if canvasData.pageTitle doesn't exist
      const title = data.pageTitle || page.name || 'Untitled Page';
      setPageTitle(title);
      // Load transform state or default to center view
      const fallbackTransform = { x: 32, y: 32, scale: 1 };
      const newTransform = data.transform || fallbackTransform;
      setTransform(newTransform);
      
      // Initialize with default container if no data exists
      if (!data.containers || data.containers.length === 0) {
        setContainers([
          { id: generateId(), type: 'text', x: 100, y: 180, content: '<div>Click anywhere to start typing...</div>', width: null }
        ]);
      }
    }, [page.id]);

    // Sync pageTitle with page.name when page.name changes externally
    useEffect(() => {
      if (page.name && page.name !== pageTitle) {
        setPageTitle(page.name);
      }
    }, [page.name]);

    // Close icon picker when clicking outside
    useEffect(() => {
      if (!showIconPicker) return;
      const handleClickOutside = (e) => {
        if (iconPickerRef.current && !iconPickerRef.current.contains(e.target)) {
          setShowIconPicker(false);
        }
      };
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }, [showIconPicker]);

    // Save to page data (including transform)
    useEffect(() => {
      onUpdate({ 
        canvasData: { 
          containers, 
          paths, 
          pageTitle,
          transform 
        },
        name: pageTitle // Sync page name with canvas title
      });
    }, [containers, paths, pageTitle, transform]);

    // History management
    const pushToHistory = () => {
      setHistory(prev => ({
        past: [...prev.past, { containers, paths }],
        future: []
      }));
    };

    const undo = () => {
      if (history.past.length === 0) return;
      const previous = history.past[history.past.length - 1];
      const newPast = history.past.slice(0, -1);
      
      setHistory({
        past: newPast,
        future: [{ containers, paths }, ...history.future]
      });
      
      setContainers(previous.containers);
      setPaths(previous.paths);
    };

    const redo = () => {
      if (history.future.length === 0) return;
      const next = history.future[0];
      const newFuture = history.future.slice(1);
      
      setHistory({
        past: [...history.past, { containers, paths }],
        future: newFuture
      });
      
      setContainers(next.containers);
      setPaths(next.paths);
    };

    // Clipboard operations
    const handleCopy = () => {
      if (!selectedId) return;
      if (selectedType === 'container' && window.getSelection().toString().length > 0) {
        return; 
      }
      if (selectedType === 'container') {
        const item = containers.find(c => c.id === selectedId);
        if (item) setAppClipboard({ type: 'container', data: item });
      } else if (selectedType === 'path') {
        const item = paths.find(p => p.id === selectedId);
        if (item) setAppClipboard({ type: 'path', data: item });
      }
    };

    const handleCut = () => {
      if (!selectedId) return;
      if (selectedType === 'container' && window.getSelection().toString().length > 0) return;
      handleCopy();
      pushToHistory();
      if (selectedType === 'container') {
        setContainers(prev => prev.filter(c => c.id !== selectedId));
      } else {
        setPaths(prev => prev.filter(p => p.id !== selectedId));
      }
      setSelectedId(null);
      setSelectedType(null);
    };

    const handleAppPaste = () => {
      if (!appClipboard) return;
      pushToHistory();
      const newId = generateId();
      if (appClipboard.type === 'container') {
        const newContainer = {
          ...appClipboard.data,
          id: newId,
          x: appClipboard.data.x + 20,
          y: appClipboard.data.y + 20
        };
        setContainers(prev => [...prev, newContainer]);
        setSelectedId(newId);
        setSelectedType('container');
      } else if (appClipboard.type === 'path') {
        const newPath = {
          ...appClipboard.data,
          id: newId,
          x: appClipboard.data.x + 20,
          y: appClipboard.data.y + 20
        };
        setPaths(prev => [...prev, newPath]);
        setSelectedId(newId);
        setSelectedType('path');
      }
    };

    // Global event listeners
    useEffect(() => {
      const handleKeyDown = (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          if (e.shiftKey) redo();
          else undo();
          return;
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          redo();
          return;
        }
        if (e.altKey && e.key === '0') {
          e.preventDefault();
          const resetTransform = { x: 32, y: 32, scale: 1 };
          setTransform(resetTransform);
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
          handleCopy();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
          handleCut();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
          if (appClipboard && document.activeElement.tagName !== 'DIV' && document.activeElement.contentEditable !== 'true') {
             e.preventDefault();
             handleAppPaste();
          }
        }
        if (e.code === 'Space' && !e.repeat && document.activeElement.tagName !== 'DIV') {
          setIsSpacePressed(true);
        }
        if (e.key === 'Delete' || e.key === 'Backspace') {
           if (selectedType === 'path' && selectedId) {
              pushToHistory();
              setPaths(prev => prev.filter(p => p.id !== selectedId));
              setSelectedId(null);
              setSelectedType(null);
           } else if (selectedType === 'container' && selectedId && document.activeElement.tagName !== 'DIV') {
              pushToHistory();
              setContainers(prev => prev.filter(c => c.id !== selectedId));
              setSelectedId(null);
              setSelectedType(null);
           }
        }
      };
      
      const handleKeyUp = (e) => {
        if (e.code === 'Space') setIsSpacePressed(false);
      };
      
      const handlePaste = async (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;

        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf('image') !== -1) {
            e.preventDefault();
            pushToHistory();
            const blob = items[i].getAsFile();
            const reader = new FileReader();
            reader.onload = (event) => {
               const viewportCenterX = (window.innerWidth / 2 - transform.x) / transform.scale;
               const viewportCenterY = (window.innerHeight / 2 - transform.y) / transform.scale;
               
               const newContainer = {
                 id: generateId(),
                 type: 'image',
                 x: viewportCenterX - 100,
                 y: viewportCenterY - 100,
                 content: event.target.result,
                 width: 300
               };
               setContainers(prev => [...prev, newContainer]);
            };
            reader.readAsDataURL(blob);
          }
        }
      };

      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      window.addEventListener('paste', handlePaste);
      return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        window.removeEventListener('paste', handlePaste);
      };
    }, [transform, selectedId, selectedType, history, appClipboard, containers, paths]);

    // Viewport logic - use useCallback to memoize and use ref for latest transform
    const transformRef = useRef(transform);
    useEffect(() => {
      transformRef.current = transform;
    }, [transform]);

    const handleWheel = useCallback((e) => {
      const currentTransform = transformRef.current;
      if (e.preventDefault) e.preventDefault();
      const zoomSensitivity = 0.001;
      const delta = -e.deltaY * zoomSensitivity;
      const newScale = Math.min(Math.max(0.1, currentTransform.scale + delta), 5);
      
      const rect = canvasRef.current ? canvasRef.current.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
      const mouseX = (e.clientX !== undefined ? e.clientX : rect.left + rect.width/2) - rect.left;
      const mouseY = (e.clientY !== undefined ? e.clientY : rect.top + rect.height/2) - rect.top;

      // Account for canvas-background offset (-25000px)
      // The transform is applied to a div positioned at -25000px
      // Canvas point (cx, cy) appears at screen: (-25000 + x + cx * scale, -25000 + y + cy * scale)
      // So canvas point under mouse: cx = (mouseX + 25000 - x) / scale
      const canvasOffset = 25000;
      
      // Calculate the canvas point under the mouse (in canvas coordinate space)
      const canvasPointX = (mouseX + canvasOffset - currentTransform.x) / currentTransform.scale;
      const canvasPointY = (mouseY + canvasOffset - currentTransform.y) / currentTransform.scale;

      // After zoom, keep same canvas point under mouse: mouseX = -25000 + newX + cx * newScale
      // So: newX = mouseX + 25000 - cx * newScale
      const newX = mouseX + canvasOffset - canvasPointX * newScale;
      const newY = mouseY + canvasOffset - canvasPointY * newScale;

      setTransform({ x: newX, y: newY, scale: newScale });
    }, []);

    // Attach wheel event listener with non-passive option to allow preventDefault
    useEffect(() => {
      const canvasElement = canvasRef.current;
      if (!canvasElement) return;

      canvasElement.addEventListener('wheel', handleWheel, { passive: false });
      return () => {
        canvasElement.removeEventListener('wheel', handleWheel);
      };
    }, [handleWheel]);

    const getCanvasCoords = (e) => {
      const rect = canvasRef.current.getBoundingClientRect();
      const canvasOffset = 25000;
      // Account for canvas-background offset (-25000px)
      // Screen position (sx, sy) -> Canvas: (sx + offset - transform.x) / scale - offset
      return {
        x: (e.clientX - rect.left + canvasOffset - transform.x) / transform.scale - canvasOffset,
        y: (e.clientY - rect.top + canvasOffset - transform.y) / transform.scale - canvasOffset
      };
    };

    // Viewport culling: calculate visible area in canvas coordinates
    // Account for canvas-background offset (-25000px) and use transform ref for latest values
    // Element at canvas (x,y) appears at screen: -25000 + transform.x + (x + 25000) * scale
    // So canvas x = (screenX + 25000 - transform.x) / scale - 25000
    const getViewportBounds = () => {
      if (!canvasRef.current) return null;
      const rect = canvasRef.current.getBoundingClientRect();
      const currentTransform = transformRef.current;
      const canvasOffset = 25000;
      const padding = 200; // Render slightly outside viewport for smooth scrolling
      
      // Convert viewport bounds from screen coordinates to canvas coordinates
      const bounds = {
        minX: (0 + canvasOffset - currentTransform.x - padding) / currentTransform.scale - canvasOffset,
        minY: (0 + canvasOffset - currentTransform.y - padding) / currentTransform.scale - canvasOffset,
        maxX: (rect.width + canvasOffset - currentTransform.x + padding) / currentTransform.scale - canvasOffset,
        maxY: (rect.height + canvasOffset - currentTransform.y + padding) / currentTransform.scale - canvasOffset
      };
      
      return bounds;
    };

    const isElementVisible = (x, y, width, height) => {
      const viewport = getViewportBounds();
      if (!viewport) return true; // Render all if viewport unknown
      return !(
        x + (width || 0) < viewport.minX ||
        x > viewport.maxX ||
        y + (height || 0) < viewport.minY ||
        y > viewport.maxY
      );
    };

    const handlePointerDown = (e) => {
      if(e.target.setPointerCapture) {
          e.target.setPointerCapture(e.pointerId);
      }

      const coords = getCanvasCoords(e);
      
      if (isSpacePressed || tool === 'hand' || e.button === 1) {
        e.preventDefault();
        setDragInfo({
          type: 'pan',
          startX: e.clientX,
          startY: e.clientY,
          initialTransform: { ...transform }
        });
        return;
      }

      if (tool === 'pen') {
        pushToHistory();
        const newPath = {
          id: generateId(),
          points: [{ x: coords.x, y: coords.y }],
          color: brushColor,
          strokeWidth: brushWidth / transform.scale,
          isArrow: e.shiftKey,
          bounds: { minX: coords.x, minY: coords.y, maxX: coords.x, maxY: coords.y },
          x: 0, y: 0 
        };
        setDrawInfo({ isDrawing: true, currentPath: newPath });
        setSelectedId(null);
        setSelectedType(null);
        return;
      }

      if (tool === 'eraser') return;

      if (e.target.id === 'canvas-background' && e.button === 0) {
        pushToHistory();
        setSelectedId(null);
        setSelectedType(null);

        const newId = generateId();
        const newContainer = {
          id: newId,
          type: 'text',
          x: coords.x - 10,
          y: coords.y - 10,
          content: '',
          width: null
        };
        setContainers([...containers, newContainer]);
        setSelectedId(newId);
        setSelectedType('container');
        setTimeout(() => {
          const el = document.getElementById(`editor-${newId}`);
          if (el) el.focus();
        }, 50);
      }
    };

    const handlePointerMove = (e) => {
      const coords = getCanvasCoords(e);
      setCursorPos(coords);

      if (dragInfo && dragInfo.type === 'pan') {
        const dx = e.clientX - dragInfo.startX;
        const dy = e.clientY - dragInfo.startY;
        setTransform({
          ...transform,
          x: dragInfo.initialTransform.x + dx,
          y: dragInfo.initialTransform.y + dy
        });
        return;
      }

      if (dragInfo && dragInfo.type === 'container') {
         const dx = (e.clientX - dragInfo.startX) / transform.scale;
         const dy = (e.clientY - dragInfo.startY) / transform.scale;
         setContainers(prev => prev.map(c => 
           c.id === dragInfo.id 
             ? { ...c, x: dragInfo.initialX + dx, y: dragInfo.initialY + dy }
             : c
         ));
         return;
      }

      if (dragInfo && dragInfo.type === 'path') {
         const dx = (e.clientX - dragInfo.startX) / transform.scale;
         const dy = (e.clientY - dragInfo.startY) / transform.scale;
         setPaths(prev => prev.map(p => 
           p.id === dragInfo.id 
             ? { ...p, x: dragInfo.initialX + dx, y: dragInfo.initialY + dy }
             : p
         ));
         return;
      }

      if (resizeInfo) {
        const dx = (e.clientX - resizeInfo.startX) / transform.scale;
        const newWidth = Math.max(100, resizeInfo.initialWidth + dx);
        setContainers(prev => prev.map(c => 
          c.id === resizeInfo.id ? { ...c, width: newWidth } : c
        ));
        return;
      }

      if (drawInfo && drawInfo.isDrawing) {
        const newPoint = { x: coords.x, y: coords.y };
        const current = drawInfo.currentPath;
        const newBounds = {
            minX: Math.min(current.bounds.minX, newPoint.x),
            minY: Math.min(current.bounds.minY, newPoint.y),
            maxX: Math.max(current.bounds.maxX, newPoint.x),
            maxY: Math.max(current.bounds.maxY, newPoint.y)
        };
        const updatedPath = { 
          ...current, 
          points: [...current.points, newPoint],
          bounds: newBounds
        };
        
        setDrawInfo({ ...drawInfo, currentPath: updatedPath });
      }
    };

    const handlePointerUp = (e) => {
      if (e.target.releasePointerCapture) {
          e.target.releasePointerCapture(e.pointerId);
      }

      if (drawInfo && drawInfo.isDrawing) {
        const p = drawInfo.currentPath;
        const finalX = p.bounds.minX;
        const finalY = p.bounds.minY;
        const normalizedPoints = p.points.map(pt => ({ x: pt.x - finalX, y: pt.y - finalY }));
        const finalPath = {
            ...p,
            points: normalizedPoints,
            x: finalX,
            y: finalY,
            width: p.bounds.maxX - p.bounds.minX, 
            height: p.bounds.maxY - p.bounds.minY,
        };
        
        setPaths([...paths, finalPath]);
      }
      setDragInfo(null);
      setResizeInfo(null);
      setDrawInfo(null);
    };

    const execCmd = (command, value = null) => {
      document.execCommand(command, false, value);
      if (selectedId && selectedType === 'container') {
         const el = document.getElementById(`editor-${selectedId}`);
         if(el) el.focus();
      }
    };

    const handleList = (command) => {
      pushToHistory();
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const container = document.getElementById(`editor-${selectedId}`);
      if (container) {
        const inputs = container.querySelectorAll('input[type="checkbox"]');
        inputs.forEach(input => {
            if (selection.containsNode(input, true) || selection.anchorNode.parentNode === input.parentNode) {
                if (input.parentElement) {
                    input.parentElement.style.textDecoration = 'none';
                    input.parentElement.style.color = 'inherit';
                }
                input.remove();
            }
        });
      }
      execCmd(command);
      if (container) {
         const cleanInputs = container.querySelectorAll('input[type="checkbox"]');
         cleanInputs.forEach(input => { if (input.closest('li')) input.remove(); });
      }
    };

    const handleMakeTodo = () => {
      pushToHistory();
      const selection = window.getSelection();
      if (!selection.rangeCount) return;

      let anchor = selection.anchorNode;
      let li = null;
      let curr = anchor;
      while(curr && curr.parentNode) {
          if (curr.id && curr.id.startsWith('editor-')) break;
          if (curr.tagName === 'LI') { li = curr; break; }
          curr = curr.parentNode;
      }

      if (li) {
          const parentList = li.parentNode;
          const cmd = parentList.tagName === 'OL' ? 'insertOrderedList' : 'insertUnorderedList';
          document.execCommand(cmd); 
      }

      if (selection.isCollapsed) {
         document.execCommand('insertHTML', false, '<input type="checkbox" style="margin-right:8px;vertical-align:middle;">&nbsp;');
      } else {
         const text = selection.toString();
         if (text) {
           const startMarkerId = `start-marker-${generateId()}`;
           const endMarkerId = `end-marker-${generateId()}`;
           const lines = text.split('\n');
           const html = `<span id="${startMarkerId}"></span>` + 
                        lines.map(line => `<div><input type="checkbox" style="margin-right:8px;vertical-align:middle;">&nbsp;${line}</div>`).join('') + 
                        `<span id="${endMarkerId}"></span>`;

           document.execCommand('insertHTML', false, html);
           
           const startEl = document.getElementById(startMarkerId);
           const endEl = document.getElementById(endMarkerId);
           if (startEl && endEl) {
               const range = document.createRange();
               range.setStartAfter(startEl);
               range.setEndBefore(endEl);
               selection.removeAllRanges();
               selection.addRange(range);
               startEl.parentNode.removeChild(startEl);
               endEl.parentNode.removeChild(endEl);
           }
         } else {
           document.execCommand('insertHTML', false, '<input type="checkbox" style="margin-right:8px;vertical-align:middle;">&nbsp;');
         }
      }
      if (selectedId) {
        const el = document.getElementById(`editor-${selectedId}`);
        if(el) el.focus();
      }
    };

    const handleSlashCommand = (command, value) => {
      if (command === 'formatBlock') {
        execCmd(command, value);
      } else if (command === 'insertHTML') {
        execCmd(command, value);
      } else if (command === 'insertUnorderedList' || command === 'insertOrderedList') {
        handleList(command);
      } else if (command === 'insertText') {
        execCmd('insertText', value);
      }
      setSlashMenu(null);
    };

    const getSvgPath = (points, isArrow) => {
      if (points.length < 2) return '';
      if (isArrow) {
         const start = points[0];
         const end = points[points.length - 1];
         return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
      }
      let d = `M ${points[0].x} ${points[0].y}`;
      for (let i = 1; i < points.length; i++) {
         d += ` L ${points[i].x} ${points[i].y}`;
      }
      return d;
    };

    const getArrowHead = (points) => {
      if (points.length < 2) return null;
      const end = points[points.length - 1];
      const start = points[0];
      const angle = Math.atan2(end.y - start.y, end.x - start.x);
      const headLen = 10;
      const x1 = end.x - headLen * Math.cos(angle - Math.PI / 6);
      const y1 = end.y - headLen * Math.sin(angle - Math.PI / 6);
      const x2 = end.x - headLen * Math.cos(angle + Math.PI / 6);
      const y2 = end.y - headLen * Math.sin(angle + Math.PI / 6);
      return `M ${end.x} ${end.y} L ${x1} ${y1} M ${end.x} ${end.y} L ${x2} ${y2}`;
    };

    const renderDefaultToolbar = () => (
      <div className="flex gap-1 items-center">
         <div className="flex gap-1 border-r border-gray-300 pr-2 mr-1">
           <ToolbarBtn icon={<Bold size={18}/>} onClick={() => execCmd('bold')} />
           <ToolbarBtn icon={<Italic size={18}/>} onClick={() => execCmd('italic')} />
           <ToolbarBtn icon={<Underline size={18}/>} onClick={() => execCmd('underline')} />
           <ToolbarBtn icon={<Strikethrough size={18}/>} onClick={() => execCmd('strikeThrough')} />
         </div>
         <div className="flex gap-1 border-r border-gray-300 pr-2 mr-1">
           <ToolbarBtn icon={<CheckSquare size={18}/>} onClick={handleMakeTodo} />
           <ToolbarBtn icon={<List size={18}/>} onClick={() => handleList('insertUnorderedList')} />
           <ToolbarBtn icon={<ListOrdered size={18}/>} onClick={() => handleList('insertOrderedList')} />
         </div>
         <div className="flex gap-1">
           <ToolbarBtn icon={<Undo size={18}/>} onClick={undo} title="Undo (Ctrl+Z)" />
           <ToolbarBtn icon={<Redo size={18}/>} onClick={redo} title="Redo (Ctrl+Y)" />
         </div>
      </div>
    );

    const renderDrawToolbar = () => (
      <div className="flex gap-3 items-center">
         <div className="flex gap-1 border-r border-gray-300 pr-3">
            {['#000000', '#FF0000', '#0000FF', '#008000'].map(c => (
               <button
                  key={c}
                  onClick={() => tool !== 'eraser' && setBrushColor(c)}
                  disabled={tool === 'eraser'}
                  className={`w-6 h-6 rounded-full border border-gray-200 transition-transform 
                     ${brushColor === c ? 'scale-110 ring-2 ring-purple-400' : ''}
                     ${tool === 'eraser' ? 'opacity-50 cursor-not-allowed' : ''}`}
                  style={{ backgroundColor: c }}
               />
            ))}
         </div>
         <div className="flex items-center gap-2 border-r border-gray-300 pr-3">
            <div className="w-1 h-1 bg-black rounded-full"/>
            <input 
              type="range" 
              min="1" 
              max="10" 
              value={brushWidth} 
              onChange={(e) => setBrushWidth(parseInt(e.target.value))}
              className="w-24 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            />
            <div className="w-3 h-3 bg-black rounded-full"/>
         </div>
         <div className="flex gap-1 border-r border-gray-300 pr-3">
            <ToolbarBtn 
               icon={<Eraser size={18} className={tool === 'eraser' ? 'text-red-600' : ''}/>} 
               onClick={() => setTool(tool === 'eraser' ? 'pen' : 'eraser')} 
               active={tool === 'eraser'}
               title="Eraser Mode"
            />
         </div>
         <div className="flex gap-1">
           <ToolbarBtn icon={<Undo size={18}/>} onClick={undo} title="Undo (Ctrl+Z)" />
           <ToolbarBtn icon={<Redo size={18}/>} onClick={redo} title="Redo (Ctrl+Y)" />
         </div>
      </div>
    );

    return (
      <div className="h-full w-full flex flex-col overflow-hidden font-sans bg-[#f8f8f8] dark:bg-gray-800 text-gray-900 dark:text-gray-100">
        <style>{`
          ul { list-style-type: disc; padding-left: 20px; }
          ul ul { list-style-type: circle; padding-left: 20px; }
          ul ul ul { list-style-type: square; padding-left: 20px; }
          ol { list-style-type: decimal; padding-left: 20px; }
          ol ol { list-style-type: lower-alpha; padding-left: 20px; }
          ol ol ol { list-style-type: lower-roman; padding-left: 20px; }
          input[type=range]::-webkit-slider-thumb {
             -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%;
             background: #7e22ce; cursor: pointer; margin-top: -4px;
          }
        `}</style>

        {/* Toolbar */}
        <div className="py-2 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 flex items-center px-4 shadow-sm shrink-0 z-50 justify-between select-none">
          <div className="flex items-center gap-2">
             <div className="flex bg-gray-100 rounded-lg p-1 gap-1 mr-4">
                <ToolbarBtn active={tool === 'cursor'} onClick={() => setTool('cursor')} icon={<MousePointer2 size={18}/>} title="Select (V)" />
                <ToolbarBtn active={tool === 'hand' || isSpacePressed} onClick={() => setTool('hand')} icon={<Hand size={18}/>} title="Pan (Space / Middle Mouse)" />
                <ToolbarBtn active={tool === 'pen' || tool === 'eraser'} onClick={() => setTool('pen')} icon={<PenTool size={18} className={tool === 'pen' || tool === 'eraser' ? 'text-purple-600' : ''}/>} title="Draw (P)" />
             </div>
             <div className="h-6 w-[1px] bg-gray-300 mx-2"/>
             {(tool === 'pen' || tool === 'eraser') ? renderDrawToolbar() : renderDefaultToolbar()}
          </div>
          <div className="flex items-center gap-4 text-sm text-gray-500">
             <div className="flex items-center gap-2 bg-gray-50 px-2 py-1 rounded border">
                <span className="text-xs font-mono">{Math.round(transform.scale * 100)}%</span>
                <div className="flex gap-1">
                   <button className="hover:bg-gray-200 p-0.5 rounded" onClick={() => handleWheel({altKey: true, deltaY: 100, clientX: window.innerWidth/2, clientY: window.innerHeight/2, preventDefault: () => {}})}>
                     <ZoomOut size={14}/>
                   </button>
                   <button className="hover:bg-gray-200 p-0.5 rounded" onClick={() => handleWheel({altKey: true, deltaY: -100, clientX: window.innerWidth/2, clientY: window.innerHeight/2, preventDefault: () => {}})}>
                     <ZoomIn size={14}/>
                   </button>
                </div>
             </div>
          </div>
        </div>

        {/* Canvas */}
        <div 
          ref={canvasRef}
          className={`flex-1 overflow-hidden relative 
            ${(tool === 'hand' || isSpacePressed) ? 'cursor-grab active:cursor-grabbing' : 
              (tool === 'pen') ? 'cursor-crosshair' : 
              (tool === 'eraser') ? 'cursor-cell' : 'cursor-default'}`}
          style={{ touchAction: 'none' }}
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerLeave={handlePointerUp}
        >
           <div 
             id="canvas-background"
             className="absolute origin-top-left w-full h-full canvas-grid"
             style={{
               left: '-25000px',
               top: '-25000px',
               transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
               backgroundSize: '20px 20px',
               backgroundPosition: `${(25000 % 20)}px ${(25000 % 20)}px`,
               width: '50000px',
               height: '50000px',
               pointerEvents: 'auto'
             }}
           >
             <div className="absolute w-[600px] select-none pointer-events-none" style={{ top: '25000px', left: '25000px' }}>
               <div className="flex items-start gap-3 pointer-events-auto">
                 <div className="relative" ref={iconPickerRef}>
                   <div 
                     className="text-5xl drop-shadow-sm select-none cursor-pointer hover:bg-gray-100/50 rounded p-2 transition-colors"
                     onClick={() => setShowIconPicker(!showIconPicker)}
                   >
                     {page.icon || 'ðŸŽ¨'}
                   </div>
                   {showIconPicker && (
                     <div className="absolute top-full left-0 z-50 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 shadow-xl rounded-lg p-2 w-64 h-64 overflow-y-auto animate-fade-in" style={{ marginTop: '4px' }}>
                       <div className="grid grid-cols-5 gap-1">
                         {EMOJIS.map(emoji => (
                           <div key={emoji} className="text-2xl cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 p-1 rounded text-center" onClick={() => { onUpdate({ icon: emoji }); setShowIconPicker(false); }}>{emoji}</div>
                         ))}
                       </div>
                     </div>
                   )}
                 </div>
                 <div className="flex-1">
                   <input 
                     value={pageTitle}
                     onChange={(e) => { 
                       const newTitle = e.target.value;
                       setPageTitle(newTitle);
                       // Immediately update page name to keep them in sync
                       onUpdate({ name: newTitle });
                     }}
                     onBlur={() => {
                       // Ensure final sync on blur
                       if (pageTitle !== page.name) {
                         onUpdate({ name: pageTitle });
                       }
                     }}
                     className="text-5xl font-light text-gray-800 dark:text-gray-200 bg-transparent border-none outline-none w-full placeholder-gray-300 dark:placeholder-gray-500"
                     placeholder="Page Title"
                   />
                   <div className="text-sm text-gray-400 dark:text-gray-500 mt-2 flex gap-4">
                     <span>{currentDate.date}</span>
                     <span>{currentDate.time}</span>
                   </div>
                 </div>
               </div>
             </div>

             {/* Paths */}
             {paths.filter(p => isElementVisible(p.x, p.y, p.width, p.height)).map(p => (
                <div
                  key={p.id}
                  className={`absolute pointer-events-auto hover:ring-1 hover:ring-purple-200 ${selectedId === p.id && selectedType === 'path' ? 'ring-1 ring-purple-500 bg-purple-50/10' : ''}`}
                  style={{ left: p.x + 25000, top: p.y + 25000, width: p.width, height: p.height, cursor: tool === 'cursor' ? 'move' : (tool === 'eraser' ? 'cell' : 'inherit') }}
                  onPointerDown={(e) => {
                     if (e.button === 1) return; // Let middle mouse bubble to canvas for panning
                     if (tool === 'cursor') {
                        e.stopPropagation();
                        setSelectedId(p.id);
                        setSelectedType('path');
                        pushToHistory();
                        setDragInfo({ type: 'path', startX: e.clientX, startY: e.clientY, initialX: p.x, initialY: p.y, id: p.id });
                     } else if (tool === 'eraser') {
                        e.stopPropagation();
                        pushToHistory();
                        setPaths(prev => prev.filter(item => item.id !== p.id));
                     }
                  }}
                  onPointerEnter={(e) => {
                     if (tool === 'eraser' && e.buttons === 1) {
                        pushToHistory();
                        setPaths(prev => prev.filter(item => item.id !== p.id));
                     }
                  }}
                >
                   <svg width="100%" height="100%" viewBox={`0 0 ${p.width} ${p.height}`} className="overflow-visible block">
                      <path d={getSvgPath(p.points, p.isArrow)} stroke={p.color} strokeWidth={p.strokeWidth * 2} fill="none" strokeLinecap="round" strokeLinejoin="round" />
                      {p.isArrow && <path d={getArrowHead(p.points)} stroke={p.color} strokeWidth={p.strokeWidth * 2} fill="none" strokeLinecap="round" strokeLinejoin="round" />}
                   </svg>
                </div>
             ))}

             {/* Active Draw - render live drawing path */}
             {drawInfo && drawInfo.isDrawing && drawInfo.currentPath.points.length > 0 && (
               <svg className="absolute pointer-events-none overflow-visible z-50" style={{ left: '0', top: '0', width: '50000px', height: '50000px' }}>
                 <g>
                    <path d={getSvgPath(drawInfo.currentPath.points.map(p => ({ x: p.x + 25000, y: p.y + 25000 })), drawInfo.currentPath.isArrow)} stroke={drawInfo.currentPath.color} strokeWidth={drawInfo.currentPath.strokeWidth * 2} fill="none" strokeLinecap="round" strokeLinejoin="round" />
                    {drawInfo.currentPath.isArrow && <path d={getArrowHead(drawInfo.currentPath.points.map(p => ({ x: p.x + 25000, y: p.y + 25000 })))} stroke={drawInfo.currentPath.color} strokeWidth={drawInfo.currentPath.strokeWidth * 2} fill="none" strokeLinecap="round" strokeLinejoin="round" />}
                 </g>
               </svg>
             )}

             {/* Containers */}
             {containers.filter(container => {
               const containerHeight = container.type === 'image' ? 200 : 100; // Approximate height
               return isElementVisible(container.x, container.y, container.width || 200, containerHeight);
             }).map(container => (
               <UniversalContainer
                 key={container.id}
                 container={container}
                 scale={transform.scale}
                 isSelected={selectedId === container.id}
                 onSelect={() => { setSelectedId(container.id); setSelectedType('container'); }}
                 onUpdate={(fields) => setContainers(prev => prev.map(c => c.id === container.id ? { ...c, ...fields } : c))}
                 onDragStart={(e) => {
                   if (e.button === 1) return; // Middle mouse only pans
                   e.stopPropagation();
                   pushToHistory();
                   setSelectedId(container.id);
                   setSelectedType('container');
                   setDragInfo({ type: 'container', startX: e.clientX, startY: e.clientY, initialX: container.x, initialY: container.y, id: container.id });
                 }}
                 onResizeStart={(e) => {
                   e.stopPropagation();
                   e.preventDefault();
                   pushToHistory();
                   setSelectedId(container.id);
                   setSelectedType('container');
                   const el = document.getElementById(`container-${container.id}`);
                   setResizeInfo({ isResizing: true, startX: e.clientX, initialWidth: container.width || (el ? el.offsetWidth : 200), id: container.id });
                 }}
                 onDelete={() => { pushToHistory(); setContainers(prev => prev.filter(c => c.id !== container.id)); }}
                 onSlash={(x, y) => setSlashMenu({ x, y, containerId: container.id })}
               />
             ))}
           </div>
        </div>
        {slashMenu && <SlashMenu x={slashMenu.x} y={slashMenu.y} onSelect={handleSlashCommand} onClose={() => setSlashMenu(null)} />}
      </div>
    );
  };

  const getCode = (p) => (p.code ?? p.mermaidCode ?? '').trim();
  const getCodeType = (p) => p.codeType || 'mermaid';

  const MERMAID_MIN_SCALE = 0.2;
  const MERMAID_MAX_SCALE = 5;
  const MERMAID_ZOOM_STEP = 0.25;

  const PYODIDE_URL = 'https://cdn.jsdelivr.net/pyodide/v0.29.2/full/pyodide.js';
  let pyodidePromise = null;

  async function loadPyodideScript() {
    if (typeof window.loadPyodide === 'function') return;
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = PYODIDE_URL;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('Failed to load Pyodide'));
      document.head.appendChild(s);
    });
  }

  async function ensurePyodide() {
    if (window.__pyodide) return window.__pyodide;
    if (pyodidePromise) return pyodidePromise;
    pyodidePromise = (async () => {
      await loadPyodideScript();
      const pyodide = await window.loadPyodide();
      window.__pyodide = pyodide;
      return pyodide;
    })();
    return pyodidePromise;
  }

  async function runPythonCode(code, pyodide) {
    const out = [];
    const append = (msg) => { out.push(msg); };
    const p = pyodide || await ensurePyodide();
    try {
      p.setStdout({ batched: append });
      p.setStderr({ batched: append });
      await p.loadPackagesFromImports(code);
      const result = p.runPython(code);
      if (result !== undefined) {
        try { out.push(String(result)); } catch (_) {}
      }
      return { output: out.join(''), error: null };
    } catch (e) {
      const errMsg = (e && e.message) ? e.message : String(e);
      return { output: out.join(''), error: errMsg };
    }
  }

  // --- TablePage Component (Database/Table Pages) ---
  const generateUUID = () => {
    if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
      return crypto.randomUUID();
    }
    // Fallback for older browsers or insecure contexts
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  };

  const DEFAULT_SCHEMA = {
    columns: [
      { id: 'c1', name: 'Item Name', type: 'text', width: 200 },
      { id: 'c2', name: 'Status', type: 'select', width: 150, options: ['Idea', 'In Progress', 'Done'] },
      { id: 'c3', name: 'Qty', type: 'number', width: 100 },
      { id: 'c4', name: 'Ordered?', type: 'boolean', width: 80 }
    ]
  };

  const DEFAULT_ROWS = [
    { id: 'r1', c1: 'Example Item', c2: 'Idea', c3: 1, c4: false }
  ];

  const TablePage = memo(({ page, onUpdate }) => {
    // --- Initialization & Default Data ---
    const [data, setData] = useState(() => {
      const content = page?.content || {};
      return {
        schema: content.schema || DEFAULT_SCHEMA,
        rows: content.rows || DEFAULT_ROWS
      };
    });

    // State for the custom "Add Column" modal
    const [isAddingColumn, setIsAddingColumn] = useState(false);
    const [newColName, setNewColName] = useState('');
    const [newColType, setNewColType] = useState('text');
    const [newColOptions, setNewColOptions] = useState('');

    // Track the current page ID to detect navigation changes
    const lastPageIdRef = useRef(page?.id);

    // Sync state when the page prop changes
    useEffect(() => {
      if (page?.id && page.id !== lastPageIdRef.current) {
        lastPageIdRef.current = page.id;
        const content = page.content || {};
        setData({
          schema: content.schema || DEFAULT_SCHEMA,
          rows: content.rows || DEFAULT_ROWS
        });
      }
    }, [page]);

    // Debounced save to parent
    const saveData = useCallback((newData) => {
      setData(newData);
      if (onUpdate && page) {
        onUpdate({ ...page, content: newData });
      }
    }, [page, onUpdate]);

    // --- Handlers ---

    const handleCellChange = (rowId, colId, value) => {
      const newRows = data.rows.map(row => 
        row.id === rowId ? { ...row, [colId]: value } : row
      );
      saveData({ ...data, rows: newRows });
    };

    const addRow = () => {
      const newRow = { id: generateUUID() };
      const columns = data.schema?.columns || [];
      columns.forEach(col => {
        newRow[col.id] = col.type === 'boolean' ? false : '';
      });
      saveData({ ...data, rows: [...data.rows, newRow] });
    };

    const deleteRow = (rowId) => {
      saveData({ ...data, rows: data.rows.filter(r => r.id !== rowId) });
    };

    const submitAddColumn = (e) => {
      e.preventDefault();
      if (!newColName.trim()) return;

      let options = undefined;
      if (newColType === 'select') {
        options = newColOptions ? newColOptions.split(',').map(s => s.trim()).filter(s => s) : ['Option 1'];
        if (options.length === 0) options = ['Option 1'];
      }

      const newCol = { 
        id: generateUUID(), 
        name: newColName, 
        type: newColType, 
        width: 150, 
        options 
      };

      const currentSchema = data.schema || { columns: [] };
      const currentColumns = currentSchema.columns || [];

      saveData({
        ...data,
        schema: { 
          ...currentSchema, 
          columns: [...currentColumns, newCol] 
        }
      });

      // Reset and close modal
      setNewColName('');
      setNewColType('text');
      setNewColOptions('');
      setIsAddingColumn(false);
    };

    // --- Render Helpers ---

    return (
      <div className="flex flex-col h-full bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 overflow-hidden relative">
        
        {/* Toolbar */}
        <div className="flex items-center gap-2 p-2 border-b border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-800">
          <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider px-2">Table Database</h2>
          <div className="flex-1"></div>
        </div>

        {/* Table Container */}
        <div className="flex-1 overflow-auto p-4 group">
          <div className="relative">
            <table className="w-full border-collapse text-sm">
              <thead>
                <tr>
                  {/* Row Handle Column */}
                  <th className="w-12 border-b-2 border-gray-300 dark:border-gray-700"></th>
                  
                  {/* Data Columns */}
                  {(data.schema?.columns || []).map(col => (
                    <th key={col.id} className="text-left font-medium text-gray-500 p-2 border-b-2 border-gray-300 dark:border-gray-700 min-w-[100px]" style={{ width: col.width }}>
                      <div className="flex items-center gap-1">
                        {getColumnIcon(col.type)}
                        <span>{col.name}</span>
                      </div>
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {data.rows.map((row, index) => (
                  <tr key={row.id} className="group hover:bg-gray-50 dark:hover:bg-gray-800/50">
                    {/* Number / Handle with Delete Button */}
                    <td className="text-center text-gray-400 text-xs border-b border-gray-200 dark:border-gray-800">
                      <div className="flex items-center justify-center gap-1">
                        <span>{index + 1}</span>
                        <button 
                          onClick={() => deleteRow(row.id)}
                          className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-500 p-1 transition-opacity"
                          title="Delete row"
                        >
                          &times;
                        </button>
                      </div>
                    </td>

                    {/* Cells */}
                    {(data.schema?.columns || []).map(col => (
                      <td key={col.id} className="border-b border-gray-200 dark:border-gray-800 p-0 relative">
                        <CellEditor 
                          type={col.type} 
                          value={row[col.id]} 
                          options={col.options}
                          onChange={(val) => handleCellChange(row.id, col.id, val)} 
                        />
                      </td>
                    ))}
                  </tr>
                ))}
                
                {/* "Add Row" Bottom Row */}
                <tr>
                  <td colSpan={(data.schema?.columns?.length || 0) + 1} className="p-2 border-b border-transparent">
                    <button onClick={addRow} className="flex items-center gap-2 text-gray-400 hover:text-blue-500 text-sm py-2">
                      <span>+ New Row</span>
                    </button>
                  </td>
                </tr>
              </tbody>
            </table>
            
            {/* Vertical Add Column Bar */}
            <button
              onClick={() => setIsAddingColumn(true)}
              className="absolute right-0 top-0 bottom-0 w-2 bg-gray-300 dark:bg-gray-600 hover:bg-blue-500 dark:hover:bg-blue-600 opacity-0 group-hover:opacity-100 transition-all duration-200 cursor-pointer z-10"
              title="Add column"
              style={{ width: '8px' }}
            >
              <span className="sr-only">Add column</span>
            </button>
          </div>
        </div>

        {/* Custom Add Column Modal */}
        {isAddingColumn && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <form onSubmit={submitAddColumn} className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl w-80 space-y-4 border border-gray-200 dark:border-gray-700">
              <h3 className="text-lg font-medium">Add New Column</h3>
              
              <div className="space-y-1">
                <label className="text-xs font-semibold text-gray-500 uppercase">Name</label>
                <input 
                  autoFocus
                  type="text" 
                  value={newColName} 
                  onChange={e => setNewColName(e.target.value)}
                  className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
                  placeholder="e.g. Price, Category"
                  required
                />
              </div>

              <div className="space-y-1">
                <label className="text-xs font-semibold text-gray-500 uppercase">Type</label>
                <select 
                  value={newColType} 
                  onChange={e => setNewColType(e.target.value)}
                  className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
                >
                  <option value="text">Text</option>
                  <option value="number">Number</option>
                  <option value="boolean">Checkbox</option>
                  <option value="select">Select (Dropdown)</option>
                </select>
              </div>

              {newColType === 'select' && (
                <div className="space-y-1">
                  <label className="text-xs font-semibold text-gray-500 uppercase">Options</label>
                  <input 
                    type="text" 
                    value={newColOptions} 
                    onChange={e => setNewColOptions(e.target.value)}
                    className="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600"
                    placeholder="Option 1, Option 2..."
                  />
                </div>
              )}

              <div className="flex justify-end gap-2 pt-2">
                <button 
                  type="button" 
                  onClick={() => setIsAddingColumn(false)}
                  className="px-3 py-2 text-sm text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded"
                >
                  Cancel
                </button>
                <button 
                  type="submit" 
                  className="px-3 py-2 text-sm bg-blue-600 text-white hover:bg-blue-700 rounded"
                >
                  Create Column
                </button>
              </div>
            </form>
          </div>
        )}
      </div>
    );
  });

  // --- Sub-Components & Helpers for TablePage ---

  function getColumnIcon(type) {
    switch (type) {
      case 'number': return <span className="opacity-50 text-xs">#</span>;
      case 'boolean': return <span className="opacity-50 text-xs">â˜‘</span>;
      case 'select': return <span className="opacity-50 text-xs">â–¼</span>;
      default: return <span className="opacity-50 text-xs">Aa</span>;
    }
  }

  // The "Smart Cell" that switches input types based on schema
  const CellEditor = ({ type, value, options, onChange }) => {
    const baseClass = "w-full h-full p-2 bg-transparent border-none outline-none focus:ring-2 focus:ring-blue-500/50 focus:bg-blue-50 dark:focus:bg-blue-900/20 transition-colors";

    if (type === 'boolean') {
      return (
        <div className="flex items-center justify-center h-full w-full">
          <input 
            type="checkbox" 
            checked={!!value} 
            onChange={(e) => onChange(e.target.checked)}
            className="w-4 h-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 cursor-pointer"
          />
        </div>
      );
    }

    if (type === 'select') {
      return (
        <select 
          value={value || ''} 
          onChange={(e) => onChange(e.target.value)}
          className={`${baseClass} appearance-none cursor-pointer`}
        >
          <option value="" disabled className="text-gray-400">Select...</option>
          {options?.map(opt => (
            <option key={opt} value={opt}>{opt}</option>
          ))}
        </select>
      );
    }

    if (type === 'number') {
      return (
        <input 
          type="number" 
          value={value || ''} 
          onChange={(e) => onChange(parseFloat(e.target.value))}
          className={`${baseClass} font-mono text-right`}
          placeholder="0"
        />
      );
    }

    // Default Text
    return (
      <input 
        type="text" 
        value={value || ''} 
        onChange={(e) => onChange(e.target.value)}
        className={baseClass}
        placeholder="Empty"
      />
    );
  };

  const MermaidPageComponent = ({ page, onUpdate, saveToHistory, showNotification, updateLocalName, syncRenameToDrive, toggleStar, activeNotebookId, activeTabId }) => {
    const codeType = getCodeType(page);
    const code = getCode(page);
    const [showCodeEdit, setShowCodeEdit] = useState(false);
    const [codeEditValue, setCodeEditValue] = useState('');
    const [codeEditType, setCodeEditType] = useState('mermaid');
    const [editingName, setEditingName] = useState(false);
    const [mermaidError, setMermaidError] = useState(null);
    const [currentTheme, setCurrentTheme] = useState(() => document.documentElement.classList.contains('dark') ? 'dark' : 'light');
    const [iframeError, setIframeError] = useState(null);
    const [pythonOutput, setPythonOutput] = useState('');
    const [pythonError, setPythonError] = useState(null);
    const [pythonLoading, setPythonLoading] = useState(false);
    const [pythonRunning, setPythonRunning] = useState(false);
    const diagramContainerRef = useRef(null);
    const mermaidInitRef = useRef(null); // Store current theme instead of boolean
    const viewportRef = useRef(null);
    const transformRef = useRef({ x: 0, y: 0, scale: 1 });
    const persistViewportRef = useRef(null);
    const hasAppliedInitialFitRef = useRef(false);
    const savedViewport = page.mermaidViewport || { x: 0, y: 0, scale: 1 };
    const [transform, setTransform] = useState(savedViewport);
    const [dragInfo, setDragInfo] = useState(null);

    useEffect(() => {
      transformRef.current = transform;
    }, [transform]);

    useEffect(() => {
      const v = page.mermaidViewport || { x: 0, y: 0, scale: 1 };
      setTransform(v);
      transformRef.current = v;
    }, [page.id]);

    const persistViewport = useCallback(() => {
      if (persistViewportRef.current) clearTimeout(persistViewportRef.current);
      persistViewportRef.current = setTimeout(() => {
        onUpdate({ mermaidViewport: transform });
        persistViewportRef.current = null;
      }, 300);
    }, [transform, onUpdate]);

    const isMermaidWithContent = codeType === 'mermaid' && code.length > 0;
    useEffect(() => {
      if (!isMermaidWithContent || mermaidError) return;
      persistViewport();
      return () => { if (persistViewportRef.current) clearTimeout(persistViewportRef.current); };
    }, [transform, isMermaidWithContent, mermaidError, persistViewport]);

    const hasDiagram = isMermaidWithContent && !mermaidError;

    const openCodeEdit = () => {
      setCodeEditValue(page.code ?? page.mermaidCode ?? '');
      setCodeEditType(getCodeType(page));
      setShowCodeEdit(true);
      setIframeError(null);
      setPythonError(null);
    };

    const handleSaveCode = () => {
      saveToHistory();
      const payload = { codeType: codeEditType, code: codeEditValue };
      if (codeEditType === 'mermaid') payload.mermaidCode = codeEditValue;
      onUpdate(payload);
      setShowCodeEdit(false);
      showNotification('Code updated', 'success');
    };

    const clampScale = (s) => Math.min(MERMAID_MAX_SCALE, Math.max(MERMAID_MIN_SCALE, s));

    const calculateZoomToFit = () => {
      if (!diagramContainerRef.current || !viewportRef.current) {
        return { x: 0, y: 0, scale: 1 };
      }

      // Find the SVG element inside the diagram container
      const svg = diagramContainerRef.current.querySelector('svg');
      if (!svg) {
        return { x: 0, y: 0, scale: 1 };
      }

      // Get SVG dimensions
      let svgWidth, svgHeight;
      const viewBox = svg.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.split(/\s+/);
        svgWidth = parseFloat(parts[2]) || svg.clientWidth || 0;
        svgHeight = parseFloat(parts[3]) || svg.clientHeight || 0;
      } else {
        svgWidth = svg.clientWidth || svg.getBBox?.()?.width || 0;
        svgHeight = svg.clientHeight || svg.getBBox?.()?.height || 0;
      }

      // Get viewport dimensions
      const viewportRect = viewportRef.current.getBoundingClientRect();
      const viewportWidth = viewportRect.width || 0;
      const viewportHeight = viewportRect.height || 0;

      // Handle edge cases
      if (svgWidth <= 0 || svgHeight <= 0 || viewportWidth <= 0 || viewportHeight <= 0) {
        return { x: 0, y: 0, scale: 1 };
      }

      // Calculate scale with 10% padding (0.9 factor)
      const scaleX = (viewportWidth * 0.9) / svgWidth;
      const scaleY = (viewportHeight * 0.9) / svgHeight;
      const scale = clampScale(Math.min(scaleX, scaleY));

      // Calculate centered position
      const scaledWidth = svgWidth * scale;
      const scaledHeight = svgHeight * scale;
      const x = (viewportWidth - scaledWidth) / 2;
      const y = (viewportHeight - scaledHeight) / 2;

      return { x, y, scale };
    };

    const handleMermaidZoom = (delta, towardCenter = true) => {
      const rect = viewportRef.current ? viewportRef.current.getBoundingClientRect() : null;
      const cx = rect ? rect.width / 2 : 0;
      const cy = rect ? rect.height / 2 : 0;
      const t = transformRef.current;
      const newScale = clampScale(t.scale + delta);
      if (!towardCenter || !rect) {
        setTransform({ ...t, scale: newScale });
        return;
      }
      const dx = (cx - t.x) / t.scale;
      const dy = (cy - t.y) / t.scale;
      const newX = cx - dx * newScale;
      const newY = cy - dy * newScale;
      setTransform({ x: newX, y: newY, scale: newScale });
    };

    const handleMermaidFit = () => {
      const fitTransform = calculateZoomToFit();
      setTransform(fitTransform);
    };

    const handleMermaidWheel = useCallback((e) => {
      const t = transformRef.current;
      const rect = viewportRef.current ? viewportRef.current.getBoundingClientRect() : { left: 0, top: 0, width: 0, height: 0 };
      const vx = e.clientX - rect.left;
      const vy = e.clientY - rect.top;
      e.preventDefault();
      const zoomSensitivity = 0.002;
      const delta = -e.deltaY * zoomSensitivity * t.scale;
      const newScale = clampScale(t.scale + delta);
      const dx = (vx - t.x) / t.scale;
      const dy = (vy - t.y) / t.scale;
      const newX = vx - dx * newScale;
      const newY = vy - dy * newScale;
      setTransform({ x: newX, y: newY, scale: newScale });
    }, []);

    useEffect(() => {
      const el = viewportRef.current;
      if (!el) return;
      el.addEventListener('wheel', handleMermaidWheel, { passive: false });
      return () => el.removeEventListener('wheel', handleMermaidWheel);
    }, [handleMermaidWheel, hasDiagram]);

    const handleMermaidPointerDown = (e) => {
      if (e.target.closest('button') || e.target.closest('a')) return;
      if (e.button === 1 || e.button === 0) {
        e.preventDefault();
        const el = e.currentTarget;
        if (el.setPointerCapture) el.setPointerCapture(e.pointerId);
        setDragInfo({ type: 'pan', startX: e.clientX, startY: e.clientY, initial: { ...transformRef.current } });
      }
    };

    const handleMermaidPointerMove = (e) => {
      if (!dragInfo || dragInfo.type !== 'pan') return;
      const dx = e.clientX - dragInfo.startX;
      const dy = e.clientY - dragInfo.startY;
      setTransform({ ...dragInfo.initial, x: dragInfo.initial.x + dx, y: dragInfo.initial.y + dy });
    };

    const handleMermaidPointerUp = (e) => {
      if (dragInfo) {
        try {
          const el = viewportRef.current;
          if (el && el.releasePointerCapture && e.pointerId !== undefined) el.releasePointerCapture(e.pointerId);
        } catch (_) {}
        setDragInfo(null);
      }
    };

    useEffect(() => {
      if (codeType !== 'mermaid' || !code || !diagramContainerRef.current) {
        setMermaidError(null);
        hasAppliedInitialFitRef.current = false;
        return;
      }
      if (typeof window.mermaid === 'undefined') {
        setMermaidError('Mermaid library not loaded');
        hasAppliedInitialFitRef.current = false;
        return;
      }
      // Reset the fit flag when chart code changes
      hasAppliedInitialFitRef.current = false;
      const el = diagramContainerRef.current;
      el.innerHTML = '';
      const pre = document.createElement('pre');
      pre.className = 'mermaid';
      pre.textContent = code;
      el.appendChild(pre);
      // Detect dark mode and use appropriate theme
      const isDarkMode = document.documentElement.classList.contains('dark');
      const mermaidTheme = isDarkMode ? 'dark' : 'default';
      
      // Reinitialize if theme changed or not initialized yet
      if (!mermaidInitRef.current || mermaidInitRef.current !== mermaidTheme) {
        try {
          window.mermaid.initialize({ startOnLoad: false, theme: mermaidTheme });
          mermaidInitRef.current = mermaidTheme;
        } catch (e) {
          setMermaidError('Failed to initialize Mermaid');
          return;
        }
      }
      setMermaidError(null);
      window.mermaid.run({ nodes: [pre] }).then(() => {
        // Wait for SVG to be rendered in the DOM
        const waitForSvg = () => {
          const svg = el.querySelector('svg');
          if (svg && !hasAppliedInitialFitRef.current) {
            // Use requestAnimationFrame to ensure layout is complete
            requestAnimationFrame(() => {
              if (!hasAppliedInitialFitRef.current && diagramContainerRef.current && viewportRef.current) {
                const fitTransform = calculateZoomToFit();
                setTransform(fitTransform);
                hasAppliedInitialFitRef.current = true;
              }
            });
          } else if (!svg) {
            // SVG not ready yet, try again
            setTimeout(waitForSvg, 50);
          }
        };
        waitForSvg();
      }).catch(() => {
        setMermaidError('Invalid Mermaid syntax');
        hasAppliedInitialFitRef.current = false;
      });
    }, [page.id, codeType, code]);

    // Watch for theme changes
    useEffect(() => {
      const observer = new MutationObserver(() => {
        const isDarkMode = document.documentElement.classList.contains('dark');
        const newTheme = isDarkMode ? 'dark' : 'light';
        if (newTheme !== currentTheme) {
          setCurrentTheme(newTheme);
        }
      });
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] });
      return () => observer.disconnect();
    }, [currentTheme]);

    // Re-render diagram when theme changes
    useEffect(() => {
      if (codeType !== 'mermaid' || !code || !diagramContainerRef.current) return;
      
      const isDarkMode = currentTheme === 'dark';
      const mermaidTheme = isDarkMode ? 'dark' : 'default';
      
      // Only reinitialize if theme changed
      if (mermaidInitRef.current !== mermaidTheme) {
        const el = diagramContainerRef.current;
        const svg = el.querySelector('svg');
        if (svg && code) {
          try {
            window.mermaid.initialize({ startOnLoad: false, theme: mermaidTheme });
            mermaidInitRef.current = mermaidTheme;
            // Clear and re-render the diagram with new theme
            el.innerHTML = '';
            const pre = document.createElement('pre');
            pre.className = 'mermaid';
            pre.textContent = code;
            el.appendChild(pre);
            window.mermaid.run({ nodes: [pre] }).catch(() => {
              setMermaidError('Invalid Mermaid syntax');
            });
          } catch (e) {
            setMermaidError('Failed to reinitialize Mermaid');
          }
        }
      }
    }, [codeType, code, currentTheme]);

    useEffect(() => {
      if (codeType !== 'python' || !code) {
        setPythonOutput('');
        setPythonError(null);
        setPythonLoading(false);
        setPythonRunning(false);
        return;
      }
      let cancelled = false;
      (async () => {
        setPythonError(null);
        setPythonLoading(true);
        setPythonRunning(false);
        setPythonOutput('');
        try {
          if (cancelled) return;
          const pyodide = await ensurePyodide();
          if (cancelled) return;
          setPythonLoading(false);
          setPythonRunning(true);
          const { output, error } = await runPythonCode(code, pyodide);
          if (cancelled) return;
          setPythonOutput(output);
          setPythonError(error);
        } catch (e) {
          if (!cancelled) setPythonError((e && e.message) ? e.message : String(e));
        } finally {
          if (!cancelled) {
            setPythonLoading(false);
            setPythonRunning(false);
          }
        }
      })();
      return () => { cancelled = true; };
    }, [page.id, codeType, code]);

    const codePlaceholder = codeEditType === 'mermaid' ? 'Paste or type Mermaid code... e.g. graph TD; A --> B;' : codeEditType === 'javascript' ? 'Paste or type JavaScript... e.g. document.body.innerHTML = \'<p>Hello</p>\';' : codeEditType === 'python' ? 'Paste or type Python... e.g. print(\'Hello\'); 1 + 2' : 'Paste or type HTML... e.g. <h1>Hi</h1> or full mini-app.';

    return (
      <div className="w-full h-full flex flex-col bg-white dark:bg-gray-800">
        <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-2 flex items-center gap-3 flex-shrink-0 flex-wrap">
          <span className="text-2xl">{page.icon || '</>'}</span>
          {editingName ? (
            <input
              className="font-semibold text-gray-700 dark:text-gray-200 outline-none border-b-2 border-blue-400 bg-transparent w-40"
              value={page.name}
              onChange={(e) => updateLocalName('page', page.id, e.target.value)}
              onBlur={() => { syncRenameToDrive('page', page.id); setEditingName(false); }}
              onKeyDown={(e) => { if (e.key === 'Enter' || e.key === 'Escape') { syncRenameToDrive('page', page.id); setEditingName(false); } }}
              onFocus={(e) => e.target.select()}
              autoFocus
            />
          ) : (
            <span
              className="font-semibold text-gray-700 dark:text-gray-200 cursor-pointer hover:text-blue-600 transition-colors w-40 truncate"
              onClick={() => setEditingName(true)}
              title={page.name}
            >
              {page.name}
            </span>
          )}
          <button
            onClick={() => toggleStar(page.id, activeNotebookId, activeTabId)}
            className={`p-1.5 rounded transition-colors ${page.starred ? 'text-yellow-400 hover:bg-yellow-50 dark:hover:bg-yellow-900/20' : 'text-gray-300 dark:text-gray-500 hover:text-yellow-400 hover:bg-gray-100 dark:hover:bg-gray-700'}`}
            title={page.starred ? 'Remove from favorites' : 'Add to favorites'}
          >
            <Star size={16} filled={page.starred} />
          </button>
          <button
            onClick={openCodeEdit}
            className="p-1.5 rounded transition-colors text-gray-500 dark:text-gray-400 hover:text-blue-600 hover:bg-gray-100 dark:hover:bg-gray-700"
            title="Edit code"
          >
            <Edit3 size={16} />
          </button>
          {hasDiagram && (
            <div className="flex items-center gap-1 ml-2 border-l border-gray-200 dark:border-gray-600 pl-2" title="Zoom and pan supported. Moving individual nodes is not supported; use the Mermaid source or spacing options to reduce overlap.">
              <button
                onClick={() => handleMermaidZoom(-MERMAID_ZOOM_STEP)}
                className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 disabled:opacity-30 disabled:cursor-not-allowed"
                disabled={transform.scale <= MERMAID_MIN_SCALE}
                title="Zoom out"
              >
                <ZoomOut size={14} />
              </button>
              <span className="text-xs text-gray-600 dark:text-gray-400 w-10 text-center font-medium tabular-nums">
                {Math.round(transform.scale * 100)}%
              </span>
              <button
                onClick={() => handleMermaidZoom(MERMAID_ZOOM_STEP)}
                className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 disabled:opacity-30 disabled:cursor-not-allowed"
                disabled={transform.scale >= MERMAID_MAX_SCALE}
                title="Zoom in"
              >
                <ZoomIn size={14} />
              </button>
              <button
                onClick={handleMermaidFit}
                className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 ml-1"
                title="Reset view (Fit)"
              >
                <Maximize2 size={14} />
              </button>
            </div>
          )}
          <span className="ml-auto text-xs text-gray-500 dark:text-gray-400 border border-gray-200 dark:border-gray-600 rounded px-2 py-0.5">
            {codeType === 'mermaid' ? 'Mermaid' : codeType === 'javascript' ? 'JavaScript' : codeType === 'python' ? 'Python' : 'HTML'}
          </span>
        </div>
        {!code ? (
          <div className="flex-1 min-h-0 overflow-auto flex flex-col items-center justify-center text-gray-500 dark:text-gray-400 p-6">
            <p className="text-sm mb-4">No code yet. Click the pencil to add code.</p>
            <button
              onClick={openCodeEdit}
              className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium rounded-lg transition-colors"
            >
              Add code
            </button>
          </div>
        ) : codeType === 'mermaid' ? (
          mermaidError ? (
            <div className="flex-1 min-h-0 overflow-auto p-6">
              <div className="text-sm text-red-600 dark:text-red-400">{mermaidError}</div>
            </div>
          ) : (
            <div
              ref={viewportRef}
              className="flex-1 min-h-0 overflow-hidden relative select-none"
              style={{ touchAction: 'none', cursor: dragInfo ? 'grabbing' : 'grab' }}
              onPointerDown={handleMermaidPointerDown}
              onPointerMove={handleMermaidPointerMove}
              onPointerUp={handleMermaidPointerUp}
              onPointerLeave={handleMermaidPointerUp}
              onPointerCancel={handleMermaidPointerUp}
            >
              <div
                className="absolute top-0 left-0 w-fit h-fit"
                style={{
                  transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`,
                  transformOrigin: '0 0'
                }}
              >
                <div ref={diagramContainerRef} className="mermaid-container flex justify-center items-start" />
              </div>
            </div>
          )
        ) : (codeType === 'html' || codeType === 'javascript') ? (
          iframeError ? (
            <div className="flex-1 min-h-0 overflow-auto p-6">
              <div className="text-sm text-red-600 dark:text-red-400">{iframeError}</div>
            </div>
          ) : (
            <div className="flex-1 min-h-0 flex flex-col p-4 overflow-hidden">
              <iframe
                title="Code output"
                sandbox="allow-scripts"
                srcDoc={codeType === 'javascript' ? '<!DOCTYPE html><html><head><meta charset="utf-8"></head><body><script>' + code.replace(/<\/script>/gi, '<\\/script>') + '</scr' + 'ipt></body></html>' : code}
                className="flex-1 min-h-0 w-full border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900"
                onError={() => setIframeError('Failed to load or run code.')}
              />
            </div>
          )
        ) : codeType === 'python' ? (
          pythonError ? (
            <div className="flex-1 min-h-0 overflow-auto p-6">
              <div className="text-sm text-red-600 dark:text-red-400 whitespace-pre-wrap font-mono">{pythonError}</div>
            </div>
          ) : (
            <div className="flex-1 min-h-0 flex flex-col p-4 overflow-hidden">
              {pythonLoading ? (
                <div className="flex-1 min-h-0 flex items-center justify-center text-gray-500 dark:text-gray-400">
                  {pythonRunning ? 'Running...' : 'Loading Pyodide...'}
                </div>
              ) : (
                <pre className="flex-1 min-h-0 w-full overflow-auto p-4 text-sm font-mono whitespace-pre-wrap border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200">
                  {pythonOutput || '\u00a0'}
                </pre>
              )}
            </div>
          )
        ) : null}
        {showCodeEdit && (
          <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
            <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-3xl w-full p-6 animate-fade-in">
              <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                  <Edit3 size={20} /> Edit code
                </h3>
                <button onClick={() => setShowCodeEdit(false)} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                  <X size={20} className="dark:text-white" />
                </button>
              </div>
              <div className="flex gap-2 mb-3">
                {['mermaid', 'javascript', 'html', 'python'].map((t) => (
                  <button
                    key={t}
                    onClick={() => setCodeEditType(t)}
                    className={`px-3 py-1.5 rounded-lg text-sm font-medium capitalize transition-colors ${codeEditType === t ? 'bg-blue-500 text-white' : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'}`}
                  >
                    {t === 'mermaid' ? 'Mermaid' : t === 'javascript' ? 'JavaScript' : t === 'python' ? 'Python' : 'HTML'}
                  </button>
                ))}
              </div>
              <textarea
                className="w-full h-64 p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white font-mono text-sm resize-y"
                placeholder={codePlaceholder}
                value={codeEditValue}
                onChange={(e) => setCodeEditValue(e.target.value)}
              />
              <div className="flex justify-end gap-3 mt-4">
                <button
                  onClick={() => setShowCodeEdit(false)}
                  className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 dark:text-gray-300 rounded-lg transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveCode}
                  className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors"
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  };

  const DEFAULT_SETTINGS = {
    theme: 'light', // 'light', 'dark', 'system'
    maxColumns: 3,
    condensedView: false,
  };

  function App() {
    const [settings, setSettings] = useState(DEFAULT_SETTINGS);
    const [showSettings, setShowSettings] = useState(false);
    const [data, setData] = useState(INITIAL_DATA);
    const [activeNotebookId, setActiveNotebookId] = useState(null);
    const [activeTabId, setActiveTabId] = useState(null);
    const [activePageId, setActivePageId] = useState(null);
    const [editingPageId, setEditingPageId] = useState(null);
    const [editingTabId, setEditingTabId] = useState(null);
    const [editingNotebookId, setEditingNotebookId] = useState(null);
    const [draggedBlock, setDraggedBlock] = useState(null);
    const [dropTarget, setDropTarget] = useState(null);
    const [activePageRows, setActivePageRows] = useState(null);
    const syncContentDebounceRef = useRef(null);
    const activePageRowsRef = useRef(null);
    const dataRef = useRef(null);
    const activeIdsRef = useRef({ notebookId: null, tabId: null, pageId: null });
    const updatePageContentRef = useRef(null);
    const [activeTabMenu, setActiveTabMenu] = useState(null); 
    const [showAddMenu, setShowAddMenu] = useState(false);
    const [autoFocusId, setAutoFocusId] = useState(null);
    const [selectedBlockId, setSelectedBlockId] = useState(null);
    const [blockMenu, setBlockMenu] = useState(null);
    const [notification, setNotification] = useState(null);
    const [itemToDelete, setItemToDelete] = useState(null);
    const [showIconPicker, setShowIconPicker] = useState(false);
    const [showCoverInput, setShowCoverInput] = useState(false);
    const [notebookIconPicker, setNotebookIconPicker] = useState(null); // { id, top, left }
    const [tabIconPicker, setTabIconPicker] = useState(null); // { id, top, left }
    const titleInputRef = useRef(null);
    const [shouldFocusTitle, setShouldFocusTitle] = useState(false);
    const shouldFocusPageRef = useRef(false);
    const [history, setHistory] = useState([]);
    const [historyIndex, setHistoryIndex] = useState(-1);
    // Creation flow tracking: { notebookId, tabId, pageId } - tracks IDs created together for Enter flow
    const [creationFlow, setCreationFlow] = useState(null);
    
    // Refs for focusing notebook/tab inputs
    const notebookInputRefs = useRef({});
    const tabInputRefs = useRef({});
    
    // Page type menu and import states
    const [showPageTypeMenu, setShowPageTypeMenu] = useState(false);
    const [showUrlImport, setShowUrlImport] = useState(false);
    const [urlImportValue, setUrlImportValue] = useState('');
    const [favoritesExpanded, setFavoritesExpanded] = useState(false);
    const [showEditEmbed, setShowEditEmbed] = useState(false);
    const [showDriveImport, setShowDriveImport] = useState(false);
    const [driveImportUrl, setDriveImportUrl] = useState('');
    const [showDocImport, setShowDocImport] = useState(false);
    const [showSheetImport, setShowSheetImport] = useState(false);
    const [showSlideImport, setShowSlideImport] = useState(false);
    const [docImportUrl, setDocImportUrl] = useState('');
    const [sheetImportUrl, setSheetImportUrl] = useState('');
    const [slideImportUrl, setSlideImportUrl] = useState('');
    const [viewedEmbedPages, setViewedEmbedPages] = useState(new Set());
    const [pageZoomLevels, setPageZoomLevels] = useState({});
    const [editEmbedName, setEditEmbedName] = useState('');
    const [editEmbedUrl, setEditEmbedUrl] = useState('');
    const [editEmbedViewMode, setEditEmbedViewMode] = useState('edit'); // 'edit' or 'preview'
    const [editingEmbedName, setEditingEmbedName] = useState(false);
    const [inlineUrlValue, setInlineUrlValue] = useState(''); // For inline URL editing in header
    const [showAccountPopup, setShowAccountPopup] = useState(false); // Hover popup for Google account
    const [showSignOutConfirm, setShowSignOutConfirm] = useState(false); // Sign out confirmation dialog
    
    const tabBarRef = useRef(null);

    // Google Drive authentication state
    const [isAuthenticated, setIsAuthenticated] = useState(false);
    const [isLoadingAuth, setIsLoadingAuth] = useState(true);
    const [userEmail, setUserEmail] = useState(null);
    const [userName, setUserName] = useState(null);
    
    // Drive sync state
    const [driveRootFolderId, setDriveRootFolderId] = useState(null);
    const [isSyncing, setIsSyncing] = useState(false);
    const [lastSyncTime, setLastSyncTime] = useState(null);
    
    // Sync lock refs to prevent concurrent operations
    const syncLockRef = useRef(false);
    const pendingSyncRef = useRef(false);
    const [structureVersion, setStructureVersion] = useState(0); // State-based trigger for structure sync
    const lastContentSyncRef = useRef(Date.now());

    // Initialize Google APIs and check auth status
    useEffect(() => {
        const initAuth = async () => {
            try {
                if (typeof GoogleAPI === 'undefined') {
                    console.warn('Google API not loaded, using localStorage fallback');
                    setIsLoadingAuth(false);
                    return;
                }

                await GoogleAPI.loadGapi();
                await GoogleAPI.initGoogleAuth();
                
                // checkAuthStatus now returns userInfo or null (restores session from storage)
                const userInfo = await GoogleAPI.checkAuthStatus();
                if (userInfo) {
                    setIsAuthenticated(true);
                    setUserEmail(userInfo.email);
                    setUserName(userInfo.name || userInfo.given_name || userInfo.email);
                } else {
                    setIsAuthenticated(false);
                }
            } catch (error) {
                console.error('Error initializing Google auth:', error);
                setIsAuthenticated(false);
            } finally {
                setIsLoadingAuth(false);
            }
        };

        initAuth();
    }, []);

    // Handle sign in
    const handleSignIn = async () => {
        try {
            setIsLoadingAuth(true);
            const userInfo = await GoogleAPI.signIn();
            setIsAuthenticated(true);
            setUserEmail(userInfo.email);
            setUserName(userInfo.name || userInfo.given_name || userInfo.email);
            showNotification('Signed in successfully', 'success');
            // Data loading is handled automatically by useEffect when isAuthenticated changes
        } catch (error) {
            console.error('Sign in error:', error);
            showNotification('Sign in failed', 'error');
        } finally {
            setIsLoadingAuth(false);
        }
    };

    // Handle sign out
    const handleSignOut = () => {
        GoogleAPI.signOut();
        setIsAuthenticated(false);
        setUserEmail(null);
        setUserName(null);
        showNotification('Signed out', 'info');
        // Reload to reset to localStorage
        window.location.reload();
    };

    useEffect(() => {
      const loadData = async () => {
        // Wait for auth to finish loading
        if (isLoadingAuth) return;

        if (isAuthenticated && typeof GoogleAPI !== 'undefined') {
          // Load from Google Drive
          try {
            const manifest = await GoogleAPI.getAppDataFile();
            if (manifest) {
              // Load data from manifest
              if (manifest.data) {
                setData(manifest.data);
                if (manifest.data.notebooks.length > 0) {
                  const firstNb = manifest.data.notebooks[0];
                  setActiveNotebookId(firstNb.id);
                  const tabId = firstNb.activeTabId || firstNb.tabs[0]?.id;
                  setActiveTabId(tabId);
                  if(tabId) {
                     const tab = firstNb.tabs.find(t => t.id === tabId);
                     if(tab) setActivePageId(tab.activePageId || tab.pages[0]?.id);
                  }
                }
              }
              
              // Load settings from manifest
              if (manifest.settings) {
                setSettings({ ...DEFAULT_SETTINGS, ...manifest.settings });
              }
            } else {
              // No manifest found, check for localStorage migration
              const saved = localStorage.getItem('note-app-data-v1');
              if (saved) {
                try {
                  const parsed = JSON.parse(saved);
                  // Migrate to Drive
                  await GoogleAPI.createAppDataFile({
                    data: parsed,
                    settings: JSON.parse(localStorage.getItem('note-app-settings-v1') || '{}'),
                    version: APP_VERSION,
                    lastModified: Date.now()
                  });
                  setData(parsed);
                  if (parsed.notebooks.length > 0) {
                    const firstNb = parsed.notebooks[0];
                    setActiveNotebookId(firstNb.id);
                    const tabId = firstNb.activeTabId || firstNb.tabs[0]?.id;
                    setActiveTabId(tabId);
                    if(tabId) {
                       const tab = firstNb.tabs.find(t => t.id === tabId);
                       if(tab) setActivePageId(tab.activePageId || tab.pages[0]?.id);
                    }
                  }
                  showNotification('Data migrated to Google Drive', 'success');
                } catch (e) {
                  console.error('Migration error:', e);
                  // Fall through to INITIAL_DATA
                }
              } else {
                // Create initial manifest
                await GoogleAPI.createAppDataFile({
                  data: INITIAL_DATA,
                  settings: DEFAULT_SETTINGS,
                  version: APP_VERSION,
                  lastModified: Date.now()
                });
                setData(INITIAL_DATA);
                setActiveNotebookId(INITIAL_DATA.notebooks[0].id);
                setActiveTabId(INITIAL_DATA.notebooks[0].tabs[0].id);
                setActivePageId(INITIAL_DATA.notebooks[0].tabs[0].pages[0].id);
              }
            }
          } catch (error) {
            console.error('Error loading from Drive:', error);
            if (error.message.includes('Authentication')) {
              showNotification('Authentication expired. Please sign in again.', 'error');
            } else {
              showNotification('Failed to load from Drive. Using local storage.', 'error');
              // Fallback to localStorage
              loadFromLocalStorage();
            }
          }
        } else {
          // Not authenticated, use localStorage
          loadFromLocalStorage();
        }
      };

      const loadFromLocalStorage = () => {
        // Load settings
        const savedSettings = localStorage.getItem('note-app-settings-v1');
        if (savedSettings) {
          try {
            setSettings({ ...DEFAULT_SETTINGS, ...JSON.parse(savedSettings) });
          } catch (e) { console.error(e); }
        }
        
        // Load data
        const saved = localStorage.getItem('note-app-data-v1');
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            setData(parsed);
            if (parsed.notebooks.length > 0) {
              const firstNb = parsed.notebooks[0];
              setActiveNotebookId(firstNb.id);
              const tabId = firstNb.activeTabId || firstNb.tabs[0]?.id;
              setActiveTabId(tabId);
              if(tabId) {
                 const tab = firstNb.tabs.find(t => t.id === tabId);
                 if(tab) setActivePageId(tab.activePageId || tab.pages[0]?.id);
              }
            }
          } catch (e) { console.error(e); }
        } else {
          setActiveNotebookId(INITIAL_DATA.notebooks[0].id);
          setActiveTabId(INITIAL_DATA.notebooks[0].tabs[0].id);
          setActivePageId(INITIAL_DATA.notebooks[0].tabs[0].pages[0].id);
        }
      };

      loadData();
    }, [isAuthenticated, isLoadingAuth]);

    // Debounced save to Drive or localStorage
    const debouncedSave = useRef(null);
    
    useEffect(() => {
        if (isLoadingAuth) return;

        // Clear existing timeout
        if (debouncedSave.current) {
            clearTimeout(debouncedSave.current);
        }

        // Debounce saves (500ms)
        debouncedSave.current = setTimeout(async () => {
            if (isAuthenticated && typeof GoogleAPI !== 'undefined') {
                // Save to Google Drive
                try {
                    await GoogleAPI.updateAppDataFile({
                        data: data,
                        settings: settings,
                        version: APP_VERSION,
                        lastModified: Date.now()
                    });
                } catch (error) {
                    console.error('Failed to save to Drive:', error);
                    if (error.message.includes('Authentication')) {
                        showNotification('Authentication expired. Please sign in again.', 'error');
                    } else {
                        showNotification('Save failed. Retrying...', 'error');
                        // Retry once after a delay
                        setTimeout(async () => {
                            try {
                                await GoogleAPI.updateAppDataFile({
                                    data: data,
                                    settings: settings,
                                    version: APP_VERSION,
                                    lastModified: Date.now()
                                });
                            } catch (retryError) {
                                console.error('Retry save failed:', retryError);
                            }
                        }, 2000);
                    }
                }
            } else {
                // Fallback to localStorage
                localStorage.setItem('note-app-data-v1', JSON.stringify(data));
            }
        }, 500);

        return () => {
            if (debouncedSave.current) {
                clearTimeout(debouncedSave.current);
            }
        };
    }, [data, settings, isAuthenticated, isLoadingAuth]);
    
    // Save settings and apply theme
    useEffect(() => { 
        if (!isAuthenticated || typeof GoogleAPI === 'undefined') {
            localStorage.setItem('note-app-settings-v1', JSON.stringify(settings));
        }
        // Apply theme
        const root = document.documentElement;
        let effectiveTheme = settings.theme;
        if (settings.theme === 'system') {
            effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }
        root.classList.remove('light', 'dark');
        root.classList.add(effectiveTheme);
    }, [settings, isAuthenticated]);
    
    // Focus sidebar nav item logic
    useEffect(() => {
        if (shouldFocusPageRef.current && activePageId) {
            const el = document.getElementById(`nav-page-${activePageId}`);
            if (el) el.focus();
            shouldFocusPageRef.current = false;
        }
    }, [activePageId]);

    // Track viewed embed pages for caching
    useEffect(() => {
        if (activePageId && activePage?.embedUrl) {
            setViewedEmbedPages(prev => new Set([...prev, activePageId]));
        }
    }, [activePageId, activePage?.embedUrl]);

    // Focus main Title logic
    useEffect(() => {
        if (shouldFocusTitle) {
            setTimeout(() => {
                if (titleInputRef.current) {
                    titleInputRef.current.focus();
                    titleInputRef.current.select();
                }
                setShouldFocusTitle(false);
            }, 100);
        }
    }, [activePageId, shouldFocusTitle]);

    // Focus notebook input when editing starts
    useEffect(() => {
        if (editingNotebookId) {
            setTimeout(() => {
                const input = notebookInputRefs.current[editingNotebookId];
                if (input) { input.focus(); input.select(); }
            }, 100);
        }
    }, [editingNotebookId]);

    // Focus tab input when editing starts
    useEffect(() => {
        if (editingTabId) {
            setTimeout(() => {
                const input = tabInputRefs.current[editingTabId];
                if (input) { input.focus(); input.select(); }
            }, 100);
        }
    }, [editingTabId]);

    // Initialize Drive root folder and sync token
    useEffect(() => {
        if (!isAuthenticated || isLoadingAuth || typeof GoogleAPI === 'undefined') return;

        const initDriveSync = async () => {
            try {
                setIsSyncing(true);
                // Ensure root folder exists and save its ID
                const rootFolderId = await GoogleAPI.getOrCreateRootFolder();
                setDriveRootFolderId(rootFolderId);
                setLastSyncTime(Date.now());
            } catch (error) {
                console.error('Error initializing Drive sync:', error);
            } finally {
                setIsSyncing(false);
            }
        };

        initDriveSync();
    }, [isAuthenticated, isLoadingAuth]);

    // Sync folder STRUCTURE to Drive (notebooks, tabs as folders; page files created but not updated)
    // This only runs when structural changes occur (add/delete/rename notebooks/tabs/pages)
    useEffect(() => {
        if (!isAuthenticated || isLoadingAuth || typeof GoogleAPI === 'undefined' || !driveRootFolderId) return;

        const syncStructure = async () => {
            // Sync lock - prevent concurrent operations
            if (syncLockRef.current) {
                pendingSyncRef.current = true;
                return;
            }
            syncLockRef.current = true;
            
            try {
                setIsSyncing(true);
                const driveIdUpdates = {}; // Only track drive IDs, not content

                // Sync each notebook (create folders only if missing)
                for (const notebook of data.notebooks) {
                    if (!notebook.driveFolderId) {
                        try {
                            const folderId = await GoogleAPI.getOrCreateFolder(notebook.name, driveRootFolderId);
                            driveIdUpdates[notebook.id] = { driveFolderId: folderId };
                        } catch (error) {
                            console.error(`Error creating folder for notebook ${notebook.name}:`, error);
                        }
                    }

                    const notebookFolderId = notebook.driveFolderId || driveIdUpdates[notebook.id]?.driveFolderId;
                    if (!notebookFolderId) continue;

                    // Sync tabs within this notebook
                    for (const tab of notebook.tabs) {
                        if (!tab.driveFolderId) {
                            try {
                                const folderId = await GoogleAPI.getOrCreateFolder(tab.name, notebookFolderId);
                                if (!driveIdUpdates[notebook.id]) driveIdUpdates[notebook.id] = { tabs: {} };
                                if (!driveIdUpdates[notebook.id].tabs) driveIdUpdates[notebook.id].tabs = {};
                                driveIdUpdates[notebook.id].tabs[tab.id] = { driveFolderId: folderId };
                            } catch (error) {
                                console.error(`Error creating folder for tab ${tab.name}:`, error);
                            }
                        }

                        const tabFolderId = tab.driveFolderId || driveIdUpdates[notebook.id]?.tabs?.[tab.id]?.driveFolderId;
                        if (!tabFolderId) continue;

                        // Create page files (but don't update content here - that's content sync)
                        for (const page of tab.pages) {
                            const pageType = page.type || 'block';
                            const isGooglePage = ['doc', 'sheet', 'slide', 'pdf', 'drive'].includes(pageType);
                            
                            // For block pages: create file only if it doesn't exist
                            if (!isGooglePage && !page.driveFileId) {
                                try {
                                    const fileId = await GoogleAPI.syncPageToDrive(page, tabFolderId);
                                    if (!driveIdUpdates[notebook.id]) driveIdUpdates[notebook.id] = { tabs: {} };
                                    if (!driveIdUpdates[notebook.id].tabs) driveIdUpdates[notebook.id].tabs = {};
                                    if (!driveIdUpdates[notebook.id].tabs[tab.id]) driveIdUpdates[notebook.id].tabs[tab.id] = { pages: {} };
                                    if (!driveIdUpdates[notebook.id].tabs[tab.id].pages) driveIdUpdates[notebook.id].tabs[tab.id].pages = {};
                                    driveIdUpdates[notebook.id].tabs[tab.id].pages[page.id] = { driveFileId: fileId };
                                } catch (error) {
                                    console.error(`Error creating file for page ${page.name}:`, error);
                                }
                            }
                            
                            // For Google pages: create JSON link file and shortcut if missing
                            if (isGooglePage && page.driveFileId) {
                                // Create JSON link file if missing
                                if (!page.driveLinkFileId) {
                                    try {
                                        const linkFileId = await GoogleAPI.syncGooglePageLink(page, tabFolderId);
                                        if (!driveIdUpdates[notebook.id]) driveIdUpdates[notebook.id] = { tabs: {} };
                                        if (!driveIdUpdates[notebook.id].tabs) driveIdUpdates[notebook.id].tabs = {};
                                        if (!driveIdUpdates[notebook.id].tabs[tab.id]) driveIdUpdates[notebook.id].tabs[tab.id] = { pages: {} };
                                        if (!driveIdUpdates[notebook.id].tabs[tab.id].pages) driveIdUpdates[notebook.id].tabs[tab.id].pages = {};
                                        driveIdUpdates[notebook.id].tabs[tab.id].pages[page.id] = { 
                                            ...(driveIdUpdates[notebook.id].tabs[tab.id].pages[page.id] || {}),
                                            driveLinkFileId: linkFileId 
                                        };
                                    } catch (error) {
                                        console.error(`Error creating link file for page ${page.name}:`, error);
                                    }
                                }
                                // Create shortcut if missing
                                if (!page.driveShortcutId) {
                                    try {
                                        const shortcut = await GoogleAPI.createDriveShortcut(page.name, page.driveFileId, tabFolderId);
                                        if (!driveIdUpdates[notebook.id]) driveIdUpdates[notebook.id] = { tabs: {} };
                                        if (!driveIdUpdates[notebook.id].tabs) driveIdUpdates[notebook.id].tabs = {};
                                        if (!driveIdUpdates[notebook.id].tabs[tab.id]) driveIdUpdates[notebook.id].tabs[tab.id] = { pages: {} };
                                        if (!driveIdUpdates[notebook.id].tabs[tab.id].pages) driveIdUpdates[notebook.id].tabs[tab.id].pages = {};
                                        driveIdUpdates[notebook.id].tabs[tab.id].pages[page.id] = { 
                                            ...(driveIdUpdates[notebook.id].tabs[tab.id].pages[page.id] || {}),
                                            driveShortcutId: shortcut.id 
                                        };
                                    } catch (error) {
                                        console.error(`Error creating shortcut for page ${page.name}:`, error);
                                    }
                                }
                            }
                        }
                    }
                }

                // Apply drive ID updates without touching content (functional update)
                if (Object.keys(driveIdUpdates).length > 0) {
                    setData(prev => {
                        const next = { ...prev, notebooks: prev.notebooks.map(notebook => {
                            const nbUpdate = driveIdUpdates[notebook.id];
                            if (!nbUpdate) return notebook;
                            
                            return {
                                ...notebook,
                                driveFolderId: nbUpdate.driveFolderId || notebook.driveFolderId,
                                tabs: notebook.tabs.map(tab => {
                                    const tabUpdate = nbUpdate.tabs?.[tab.id];
                                    if (!tabUpdate) return tab;
                                    
                                    return {
                                        ...tab,
                                        driveFolderId: tabUpdate.driveFolderId || tab.driveFolderId,
                                        pages: tab.pages.map(page => {
                                            const pageUpdate = tabUpdate.pages?.[page.id];
                                            if (!pageUpdate) return page;
                                            
                                            return {
                                                ...page,
                                                driveFileId: pageUpdate.driveFileId || page.driveFileId,
                                                driveShortcutId: pageUpdate.driveShortcutId || page.driveShortcutId,
                                                driveLinkFileId: pageUpdate.driveLinkFileId || page.driveLinkFileId
                                            };
                                        })
                                    };
                                })
                            };
                        })};
                        return next;
                    });
                }
                
                // Update manifest.json and index.html (only on structure sync)
                try {
                    await GoogleAPI.updateManifest(data, driveRootFolderId, APP_VERSION);
                    await GoogleAPI.uploadIndexHtml(generateOfflineViewerHtml(), driveRootFolderId);
                } catch (error) {
                    console.error('Error updating manifest/index.html:', error);
                }
                
                setLastSyncTime(Date.now());
            } catch (error) {
                console.error('Error syncing structure:', error);
            } finally {
                setIsSyncing(false);
                syncLockRef.current = false;
                
                // If a sync was requested while we were syncing, run it now
                if (pendingSyncRef.current) {
                    pendingSyncRef.current = false;
                    setTimeout(syncStructure, 1000);
                }
            }
        };

        // Longer debounce for structure sync (5 seconds)
        const syncTimeout = setTimeout(syncStructure, 5000);
        return () => clearTimeout(syncTimeout);
    }, [structureVersion, isAuthenticated, isLoadingAuth, driveRootFolderId]);

    // Content sync - update page content files after user stops editing (idle detection)
    useEffect(() => {
        if (!isAuthenticated || isLoadingAuth || typeof GoogleAPI === 'undefined' || !driveRootFolderId) return;
        
        const syncContent = async () => {
            // Don't sync content if structure sync is running
            if (syncLockRef.current) return;
            
            // Find pages that have driveFileId and need content update
            for (const notebook of data.notebooks) {
                for (const tab of notebook.tabs) {
                    const tabFolderId = tab.driveFolderId;
                    if (!tabFolderId) continue;
                    
                    for (const page of tab.pages) {
                        const pageType = page.type || 'block';
                        const isGooglePage = ['doc', 'sheet', 'slide', 'pdf', 'drive'].includes(pageType);
                        
                        // Only sync block pages that already have a driveFileId
                        if (!isGooglePage && page.driveFileId) {
                            try {
                                await GoogleAPI.syncPageToDrive(page, tabFolderId);
                            } catch (error) {
                                console.error(`Error updating page content ${page.name}:`, error);
                            }
                        }
                    }
                }
            }
            lastContentSyncRef.current = Date.now();
        };

        // Content sync after 10 seconds of idle (longer debounce to avoid conflicts)
        const contentSyncTimeout = setTimeout(syncContent, 10000);
        return () => clearTimeout(contentSyncTimeout);
    }, [data.notebooks, isAuthenticated, isLoadingAuth, driveRootFolderId]);

    // Reconciliation - verify Drive folder/file names match the notebook and fix mismatches
    // Runs periodically to catch any sync issues
    useEffect(() => {
        if (!isAuthenticated || isLoadingAuth || typeof GoogleAPI === 'undefined' || !driveRootFolderId) return;
        
        const reconcileDrive = async () => {
            // Don't reconcile if sync is running
            if (syncLockRef.current) return;
            
            console.log('Running Drive reconciliation...');
            let fixCount = 0;
            
            for (const notebook of data.notebooks) {
                if (notebook.driveFolderId) {
                    try {
                        const driveItem = await GoogleAPI.getDriveItem(notebook.driveFolderId);
                        const expectedName = GoogleAPI.sanitizeFileName(notebook.name);
                        if (driveItem && !driveItem.trashed && driveItem.name !== expectedName) {
                            console.log(`Fixing notebook folder: "${driveItem.name}" -> "${expectedName}"`);
                            await GoogleAPI.renameDriveItem(notebook.driveFolderId, expectedName);
                            fixCount++;
                        }
                    } catch (error) {
                        console.error(`Error reconciling notebook ${notebook.name}:`, error);
                    }
                }
                
                for (const tab of notebook.tabs) {
                    if (tab.driveFolderId) {
                        try {
                            const driveItem = await GoogleAPI.getDriveItem(tab.driveFolderId);
                            const expectedName = GoogleAPI.sanitizeFileName(tab.name);
                            if (driveItem && !driveItem.trashed && driveItem.name !== expectedName) {
                                console.log(`Fixing tab folder: "${driveItem.name}" -> "${expectedName}"`);
                                await GoogleAPI.renameDriveItem(tab.driveFolderId, expectedName);
                                fixCount++;
                            }
                        } catch (error) {
                            console.error(`Error reconciling tab ${tab.name}:`, error);
                        }
                    }
                    
                    for (const page of tab.pages) {
                        if (page.driveFileId) {
                            try {
                                const driveItem = await GoogleAPI.getDriveItem(page.driveFileId);
                                const expectedName = GoogleAPI.sanitizeFileName(page.name) + '.json';
                                if (driveItem && !driveItem.trashed && driveItem.name !== expectedName) {
                                    console.log(`Fixing page file: "${driveItem.name}" -> "${expectedName}"`);
                                    await GoogleAPI.renameDriveItem(page.driveFileId, expectedName);
                                    fixCount++;
                                }
                            } catch (error) {
                                console.error(`Error reconciling page ${page.name}:`, error);
                            }
                        }
                    }
                }
            }
            
            if (fixCount > 0) {
                console.log(`Reconciliation complete: fixed ${fixCount} item(s)`);
                showNotification(`Fixed ${fixCount} Drive item(s)`, 'info');
            }
        };

        // Run reconciliation 15 seconds after load/auth, then every 60 seconds
        const initialReconcile = setTimeout(reconcileDrive, 15000);
        const reconcileInterval = setInterval(reconcileDrive, 60000);
        
        return () => {
            clearTimeout(initialReconcile);
            clearInterval(reconcileInterval);
        };
    }, [isAuthenticated, isLoadingAuth, driveRootFolderId, data.notebooks]);

    // NOTE: Polling for Drive changes has been removed.
    // The notebook is now the "master" - it only PUSHES changes to Drive.
    // This eliminates the "bounce" effect where changes would sync back and forth.
    // Multi-user collaboration can be added later as a separate feature.

    useEffect(() => {
      const handleClickOutside = (e) => {
         if (!e.target.closest('.tab-settings-trigger') && !e.target.closest('.tab-settings-menu')) setActiveTabMenu(null);
         if (!e.target.closest('.add-menu-container')) setShowAddMenu(false);
         if (!e.target.closest('.block-handle') && !e.target.closest('.block-menu')) {
             if (!e.target.closest('[contenteditable="true"]')) setSelectedBlockId(null);
             setBlockMenu(null);
         }
         if (editingTabId && !e.target.closest('.tab-input')) setEditingTabId(null);
         if (editingNotebookId && !e.target.closest('.notebook-input')) setEditingNotebookId(null);
         if (editingPageId && !e.target.closest('.page-input')) setEditingPageId(null);
         if (!e.target.closest('.icon-picker-trigger') && !e.target.closest('.icon-picker')) setShowIconPicker(false);
         if (!e.target.closest('.cover-input-trigger') && !e.target.closest('.cover-input')) setShowCoverInput(false);
         if (!e.target.closest('.notebook-icon-trigger') && !e.target.closest('.notebook-icon-picker')) setNotebookIconPicker(null);
         if (!e.target.closest('.tab-icon-trigger') && !e.target.closest('.tab-icon-picker')) setTabIconPicker(null);
         if (!e.target.closest('.settings-modal') && !e.target.closest('.settings-trigger')) setShowSettings(false);
         if (!e.target.closest('.page-type-menu') && !e.target.closest('.page-type-trigger')) setShowPageTypeMenu(false);
      };
      document.addEventListener('click', handleClickOutside);
      return () => document.removeEventListener('click', handleClickOutside);
    }, [editingTabId, editingNotebookId, editingPageId]);

    const showNotification = (message, type = 'info') => {
        setNotification({ message, type });
        setTimeout(() => setNotification(null), 3000);
    };

    const saveToHistory = (newData) => {
        const newHistory = history.slice(0, historyIndex + 1);
        newHistory.push(newData ? newData : JSON.parse(JSON.stringify(data)));
        if (newHistory.length > 30) newHistory.shift();
        setHistory(newHistory);
        setHistoryIndex(newHistory.length - 1);
    };

    const undo = () => {
        if (historyIndex > 0) {
            const prevData = history[historyIndex - 1];
            setData(prevData);
            setHistoryIndex(historyIndex - 1);
            showNotification('Undo', 'info');
        }
    };

    const redo = () => {
        if (historyIndex < history.length - 1) {
            const nextData = history[historyIndex + 1];
            setData(nextData);
            setHistoryIndex(historyIndex + 1);
            showNotification('Redo', 'info');
        }
    };

    const { notebook: activeNotebook, tab: activeTab, page: activePage } = getActiveContext(data, activeNotebookId, activeTabId, activePageId);
    const rowsForEditor = activePageRows ?? activePage?.rows ?? [];

    const flushActivePageToData = (rows) => {
        if (!activePageId || !activeTabId || !activeNotebookId) return;
        const next = updatePageInData(data, { notebookId: activeNotebookId, tabId: activeTabId, pageId: activePageId }, p => ({ ...p, rows: rows ?? activePageRows }));
        setData(next);
        return next;
    };

    const scheduleSyncToData = () => {
        if (syncContentDebounceRef.current) clearTimeout(syncContentDebounceRef.current);
        syncContentDebounceRef.current = setTimeout(() => {
            syncContentDebounceRef.current = null;
            const d = dataRef.current;
            const r = activePageRowsRef.current;
            const { notebookId, tabId, pageId } = activeIdsRef.current;
            if (!d || !pageId || !tabId || !notebookId || !r) return;
            setData(updatePageInData(d, { notebookId, tabId, pageId }, p => ({ ...p, rows: r })));
        }, 300);
    };

    const flushAndClearSync = () => {
        if (syncContentDebounceRef.current) {
            clearTimeout(syncContentDebounceRef.current);
            syncContentDebounceRef.current = null;
        }
        if (activePageId && activeTabId && activeNotebookId && activePageRows != null) {
            flushActivePageToData(activePageRows);
        }
    };

    useEffect(() => {
        const ctx = getActiveContext(data, activeNotebookId, activeTabId, activePageId);
        setActivePageRows(ctx.page ? (ctx.page.rows ?? []) : null);
    }, [data, activePageId, activeTabId, activeNotebookId]);

    useEffect(() => {
        dataRef.current = data;
        activePageRowsRef.current = activePageRows;
        activeIdsRef.current = { notebookId: activeNotebookId, tabId: activeTabId, pageId: activePageId };
    });

    const updatePageContent = (rows, shouldSaveHistory = false) => {
        if (!activePageId || !activeTabId || !activeNotebookId) return;
        setActivePageRows(rows);
        if (shouldSaveHistory) {
            const next = updatePageInData(data, { notebookId: activeNotebookId, tabId: activeTabId, pageId: activePageId }, p => ({ ...p, rows }));
            setData(next);
            saveToHistory(next);
        } else {
            scheduleSyncToData();
        }
    };

    const updatePageMeta = (updates) => {
        if (!activePageId) return;
        saveToHistory();
        setData(prev => updatePageInData(prev, { notebookId: activeNotebookId, tabId: activeTabId, pageId: activePageId }, p => ({ ...p, ...updates })));
    };

    const removeBlock = (blockId) => {
        const newRows = rowsForEditor.map(row => ({
            ...row,
            columns: row.columns.map(col => ({
                ...col,
                blocks: col.blocks.filter(b => b.id !== blockId)
            })).filter(col => col.blocks.length > 0)
        })).filter(row => row.columns.length > 0);
        updatePageContent(newRows, true);
        showNotification('Block deleted', 'success');
    };

    useEffect(() => { updatePageContentRef.current = updatePageContent; });

    const handleUpdateBlock = useCallback((blockId, updates) => {
        const r = activePageRowsRef.current;
        if (!r) return;
        const newRows = r.map(row => ({
            ...row,
            columns: row.columns.map(col => ({
                ...col,
                blocks: col.blocks.map(b => b.id === blockId ? { ...b, ...updates } : b)
            }))
        }));
        setActivePageRows(newRows);
        scheduleSyncToData();
    }, []);

    const handleRemoveBlock = useCallback((blockId) => {
        const r = activePageRowsRef.current;
        if (!r) return;
        const newRows = r.map(row => ({
            ...row,
            columns: row.columns.map(col => ({
                ...col,
                blocks: col.blocks.filter(b => b.id !== blockId)
            })).filter(col => col.blocks.length > 0)
        })).filter(row => row.columns.length > 0);
        const fn = updatePageContentRef.current;
        if (fn) fn(newRows, true);
        showNotification('Block deleted', 'success');
    }, []);

    const handleInsertBlockAfter = useCallback((targetBlockId, blockType) => {
        const r = activePageRowsRef.current;
        const ids = activeIdsRef.current;
        if (!r || !ids.pageId || !ids.tabId || !ids.notebookId) return;
        const newBlockId = generateId();
        const newBlock = { id: newBlockId, type: blockType, content: '', url: '', ...(blockType === 'todo' ? { checked: false } : {}) };
        const newRows = JSON.parse(JSON.stringify(r));
        let done = false;
        for (const row of newRows) {
            for (const col of row.columns) {
                const idx = col.blocks.findIndex(b => b.id === targetBlockId);
                if (idx > -1) {
                    col.blocks.splice(idx + 1, 0, newBlock);
                    done = true;
                    break;
                }
            }
            if (done) break;
        }
        if (done) {
            const fn = updatePageContentRef.current;
            if (fn) fn(newRows, true);
            setAutoFocusId(newBlockId);
        }
    }, []);

    const handleRequestFocus = useCallback((blockId) => setAutoFocusId(blockId), []);
    const handleBlockFocus = useCallback(() => {
        setSelectedBlockId(null);
        setBlockMenu(null);
        setAutoFocusId(null);
    }, []);
    const handleBlockHandleClick = useCallback((e, blockId) => {
        e.stopPropagation();
        if (selectedBlockId === blockId) {
            const rect = e.currentTarget.getBoundingClientRect();
            setBlockMenu({ id: blockId, top: rect.bottom + 5, left: rect.left });
        } else {
            setSelectedBlockId(blockId);
            setBlockMenu(null);
            if (document.activeElement instanceof HTMLElement) document.activeElement.blur();
        }
    }, [selectedBlockId]);
    const handleBlockDragStart = useCallback((e, block, rowId, colId) => {
        e.dataTransfer.setData('block_drag', JSON.stringify({ block, rowId, colId }));
        setDraggedBlock({ block, rowId, colId });
    }, []);

    const lastDropTargetRef = useRef(null);
    const dropTargetRafRef = useRef(null);

    const handleBlockDragEnd = useCallback(() => {
        if (dropTargetRafRef.current) {
            cancelAnimationFrame(dropTargetRafRef.current);
            dropTargetRafRef.current = null;
        }
        lastDropTargetRef.current = null;
        setDraggedBlock(null);
        setDropTarget(null);
    }, []);

    const handleBlockDragOver = useCallback((e, blockId, rowId, colId) => {
        e.preventDefault();
        e.stopPropagation();
        if (!draggedBlock || draggedBlock.block.id === blockId) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const w = rect.width;
        const h = rect.height;
        let position = 'bottom';
        if (y < h * 0.3) position = 'top';
        const targetRow = rowsForEditor.find(r => r.id === rowId);
        const isMaxColumns = targetRow && targetRow.columns.length >= settings.maxColumns;
        if (!isMaxColumns) {
            if (x < w * 0.2) position = 'left';
            else if (x > w * 0.8) position = 'right';
        }
        const next = { rowId, colId, blockId, position };
        const last = lastDropTargetRef.current;
        if (last && last.blockId === next.blockId && last.position === next.position && last.rowId === next.rowId && last.colId === next.colId) return;
        lastDropTargetRef.current = next;
        if (dropTargetRafRef.current) cancelAnimationFrame(dropTargetRafRef.current);
        dropTargetRafRef.current = requestAnimationFrame(() => {
            dropTargetRafRef.current = null;
            setDropTarget(next);
        });
    }, [draggedBlock, rowsForEditor, settings]);

    useEffect(() => {
        const handleKeyDown = (e) => {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const redoKey = isMac ? (e.metaKey && e.shiftKey && e.key.toLowerCase() === 'z') : (e.ctrlKey && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z')));
            const undoKey = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey;

            if (redoKey) { e.preventDefault(); redo(); } 
            else if (undoKey) { e.preventDefault(); undo(); }
            
            if (selectedBlockId && e.key === 'Delete') {
                e.preventDefault();
                handleRemoveBlock(selectedBlockId);
                setSelectedBlockId(null);
                setBlockMenu(null);
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [history, historyIndex, data, selectedBlockId, handleRemoveBlock]);

    const selectNotebook = (notebookId) => {
        const nb = data.notebooks.find(n => n.id === notebookId);
        if (!nb) return;
        flushAndClearSync();
        setActiveNotebookId(notebookId);
        setEditingPageId(null);
        setEditingTabId(null);
        setEditingNotebookId(null);
        const targetTabId = nb.activeTabId || (nb.tabs && nb.tabs[0] ? nb.tabs[0].id : null);
        setActiveTabId(targetTabId);
        if (targetTabId) {
            const tab = nb.tabs.find(t => t.id === targetTabId);
            setActivePageId(tab ? (tab.activePageId || (tab.pages && tab.pages[0] ? tab.pages[0].id : null)) : null);
        } else {
            setActivePageId(null);
        }
    };

    const selectTab = (tabId) => {
        flushAndClearSync();
        setActiveTabId(tabId);
        setEditingPageId(null);
        setEditingTabId(null);
        setEditingNotebookId(null);
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => 
                nb.id === activeNotebookId ? { ...nb, activeTabId: tabId } : nb
            )
        }));
        const nb = data.notebooks.find(n => n.id === activeNotebookId);
        const tab = nb?.tabs.find(t => t.id === tabId);
        if (tab) {
            setActivePageId(tab.activePageId || (tab.pages && tab.pages[0] ? tab.pages[0].id : null));
        }
    };

    const selectPage = (pageId) => {
        flushAndClearSync();
        setActivePageId(pageId);
        setEditingPageId(null);
        setEditingTabId(null);
        setEditingNotebookId(null);
        // Track viewed embed pages for caching
        const page = data.notebooks.flatMap(nb => nb.tabs.flatMap(t => t.pages)).find(p => p.id === pageId);
        if (page?.embedUrl) {
            setViewedEmbedPages(prev => new Set([...prev, pageId]));
        }
        
        // Persist the last open page to the tab
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => 
                nb.id !== activeNotebookId ? nb : {
                    ...nb,
                    tabs: nb.tabs.map(t => 
                        t.id === activeTabId ? { ...t, activePageId: pageId } : t
                    )
                }
            )
        }));
    };

    const toggleStar = (pageId, notebookId, tabId) => {
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => 
                nb.id !== notebookId ? nb : {
                    ...nb,
                    tabs: nb.tabs.map(t => 
                        t.id !== tabId ? t : {
                            ...t,
                            pages: t.pages.map(p => 
                                p.id === pageId ? { ...p, starred: !p.starred } : p
                            )
                        }
                    )
                }
            )
        }));
    };

    // Zoom helpers for embedded pages
    const getPageZoom = (pageId) => pageZoomLevels[pageId] || 100;
    const setPageZoom = (pageId, zoom) => {
        const clampedZoom = Math.min(200, Math.max(25, zoom));
        setPageZoomLevels(prev => ({ ...prev, [pageId]: clampedZoom }));
    };

    const showZoomForEmbed = (page) =>
        page?.embedUrl &&
        page.embedUrl.includes('/preview') &&
        (page.embedUrl.includes('/document/') || page.embedUrl.includes('/spreadsheets/'));

    // Toggle between edit and preview mode for Google pages
    const toggleViewMode = (pageId) => {
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => ({
                ...nb,
                tabs: nb.tabs.map(t => ({
                    ...t,
                    pages: t.pages.map(p => {
                        if (p.id !== pageId || !p.embedUrl) return p;
                        
                        // Toggle between /preview and /edit in the URL
                        let newEmbedUrl;
                        if (p.embedUrl.includes('/preview')) {
                            newEmbedUrl = p.embedUrl.replace('/preview', '/edit');
                        } else if (p.embedUrl.includes('/edit')) {
                            newEmbedUrl = p.embedUrl.replace('/edit', '/preview');
                        } else {
                            return p; // No change if neither found
                        }
                        return { ...p, embedUrl: newEmbedUrl };
                    })
                }))
            }))
        }));
    };

    // Get all starred pages across all notebooks/tabs
    const getStarredPages = () => {
        const starred = [];
        data.notebooks.forEach(nb => {
            nb.tabs.forEach(tab => {
                tab.pages.forEach(page => {
                    if (page.starred) {
                        starred.push({
                            ...page,
                            notebookId: nb.id,
                            tabId: tab.id,
                            notebookName: nb.name,
                            tabName: tab.name
                        });
                    }
                });
            });
        });
        return starred;
    };

    // Helper to create a default page with one empty text block
    const createDefaultPage = (name = 'New Page') => {
      return { 
        id: generateId(), 
        name, 
        createdAt: Date.now(), 
        rows: [{ id: generateId(), columns: [{ id: generateId(), blocks: [{ id: generateId(), type: 'text', content: '' }] }] }],
        icon: 'ðŸ“„', 
        cover: 'https://images.unsplash.com/photo-1579546929518-9e396f3cc809?auto=format&fit=crop&w=1200&q=80',
      };
    };

    const createCanvasPage = (name = 'Untitled Canvas') => {
      return {
        id: generateId(),
        name,
        createdAt: Date.now(),
        type: 'canvas',
        icon: 'ðŸŽ¨',
        canvasData: {
          containers: [],
          paths: [],
          pageTitle: name
        }
      };
    };

    const createCodePage = (name = 'Code Page') => {
      return {
        id: generateId(),
        name,
        createdAt: Date.now(),
        type: 'mermaid',
        icon: '</>',
        codeType: 'mermaid',
        code: '',
        mermaidCode: ''
      };
    };

    const createDatabasePage = (name = 'Database') => {
      return {
        id: generateId(),
        name,
        createdAt: Date.now(),
        type: 'database',
        icon: 'ðŸ—„ï¸',
        content: {
          schema: {
            columns: [
              { id: 'c1', name: 'Item Name', type: 'text', width: 200 },
              { id: 'c2', name: 'Status', type: 'select', width: 150, options: ['Idea', 'In Progress', 'Done'] },
              { id: 'c3', name: 'Qty', type: 'number', width: 100 },
              { id: 'c4', name: 'Ordered?', type: 'boolean', width: 80 }
            ]
          },
          rows: [
            { id: 'r1', c1: 'Example Item', c2: 'Idea', c3: 1, c4: false }
          ]
        }
      };
    };

    const addNotebook = async () => {
      saveToHistory();
      const newPage = createDefaultPage();
      const newTab = { id: generateId(), name: 'New Tab', icon: 'ðŸ“‹', color: COLORS[0].name, pages: [newPage], activePageId: newPage.id };
      const newNb = { id: generateId(), name: 'New Notebook', icon: 'ðŸ““', tabs: [newTab], activeTabId: newTab.id };
      const newData = { ...data, notebooks: [...data.notebooks, newNb] };
      setData(newData);
      setActiveNotebookId(newNb.id);
      setActiveTabId(newTab.id);
      setActivePageId(newPage.id);
      setEditingPageId(null);
      setEditingTabId(null);
      setEditingNotebookId(newNb.id);
      // Set creation flow to enable Enter key navigation: notebook â†’ tab â†’ page title
      setCreationFlow({ notebookId: newNb.id, tabId: newTab.id, pageId: newPage.id });
      showNotification('Notebook created', 'success');
      // Trigger structure sync
      setStructureVersion(v => v + 1);
      
      // Sync to Drive if authenticated
      if (isAuthenticated && typeof GoogleAPI !== 'undefined') {
          try {
              const rootFolderId = await GoogleAPI.getOrCreateRootFolder();
              const notebookFolderId = await GoogleAPI.syncNotebookToDrive(newNb, rootFolderId);
              const tabFolderId = await GoogleAPI.syncTabToDrive(newTab, notebookFolderId);
              const pageFileId = await GoogleAPI.syncPageToDrive(newPage, tabFolderId);
              
              // Update local data with Drive IDs
              setData(prev => ({
                  ...prev,
                  notebooks: prev.notebooks.map(nb => 
                      nb.id === newNb.id ? {
                          ...nb,
                          driveFolderId: notebookFolderId,
                          tabs: nb.tabs.map(tab => 
                              tab.id === newTab.id ? {
                                  ...tab,
                                  driveFolderId: tabFolderId,
                                  pages: tab.pages.map(page => 
                                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                                  )
                              } : tab
                          )
                      } : nb
                  )
              }));
          } catch (error) {
              console.error('Error syncing notebook to Drive:', error);
          }
      }
    };

    const addTab = async () => {
      if (!activeNotebookId) return;
      saveToHistory();
      const activeNotebook = data.notebooks.find(nb => nb.id === activeNotebookId);
      const newPage = createDefaultPage();
      const newTab = { id: generateId(), name: 'New Tab', icon: 'ðŸ“‹', color: getNextTabColor(activeNotebook?.tabs), pages: [newPage], activePageId: newPage.id };
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb => 
          nb.id === activeNotebookId ? { ...nb, tabs: [...nb.tabs, newTab], activeTabId: newTab.id } : nb
        )
      };
      setData(newData);
      setActiveTabId(newTab.id);
      setActivePageId(newPage.id);
      setEditingPageId(null);
      setEditingTabId(newTab.id);
      setEditingNotebookId(null);
      showNotification('Section created', 'success');
      // Trigger structure sync
      setStructureVersion(v => v + 1);
      
      // Sync to Drive if authenticated
      if (isAuthenticated && typeof GoogleAPI !== 'undefined' && activeNotebook?.driveFolderId) {
          try {
              const tabFolderId = await GoogleAPI.syncTabToDrive(newTab, activeNotebook.driveFolderId);
              const pageFileId = await GoogleAPI.syncPageToDrive(newPage, tabFolderId);
              
              // Update local data with Drive IDs
              setData(prev => ({
                  ...prev,
                  notebooks: prev.notebooks.map(nb => 
                      nb.id === activeNotebookId ? {
                          ...nb,
                          tabs: nb.tabs.map(tab => 
                              tab.id === newTab.id ? {
                                  ...tab,
                                  driveFolderId: tabFolderId,
                                  pages: tab.pages.map(page => 
                                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                                  )
                              } : tab
                          )
                      } : nb
                  )
              }));
          } catch (error) {
              console.error('Error syncing tab to Drive:', error);
          }
      }
    };

    const addPage = async () => {
      if (!activeTabId) return;
      saveToHistory();
      const newPage = createDefaultPage();
      const activeNotebook = data.notebooks.find(nb => nb.id === activeNotebookId);
      const activeTab = activeNotebook?.tabs.find(t => t.id === activeTabId);
      
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
              ...nb,
              tabs: nb.tabs.map(tab => 
                  tab.id !== activeTabId ? tab : {
                      ...tab,
                      pages: [...tab.pages, newPage],
                      activePageId: newPage.id
                  }
              )
          }
        )
      };
      setData(newData);
      setActivePageId(newPage.id);
      setEditingPageId(null);  // Don't edit in sidebar
      setEditingTabId(null);
      setEditingNotebookId(null);
      setShouldFocusTitle(true); // Focus main title
      showNotification('Page created', 'success');
      // Trigger structure sync
      setStructureVersion(v => v + 1);
      
      // Sync to Drive if authenticated
      if (isAuthenticated && typeof GoogleAPI !== 'undefined' && activeTab?.driveFolderId) {
          try {
              const pageFileId = await GoogleAPI.syncPageToDrive(newPage, activeTab.driveFolderId);
              
              // Update local data with Drive ID
              setData(prev => ({
                  ...prev,
                  notebooks: prev.notebooks.map(nb => 
                      nb.id === activeNotebookId ? {
                          ...nb,
                          tabs: nb.tabs.map(tab => 
                              tab.id === activeTabId ? {
                                  ...tab,
                                  pages: tab.pages.map(page => 
                                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                                  )
                              } : tab
                          )
                      } : nb
                  )
              }));
          } catch (error) {
              console.error('Error syncing page to Drive:', error);
          }
      }
    };

    const addCanvasPage = async () => {
      if (!activeTabId) return;
      saveToHistory();
      const newPage = createCanvasPage();
      const activeNotebook = data.notebooks.find(nb => nb.id === activeNotebookId);
      const activeTab = activeNotebook?.tabs.find(t => t.id === activeTabId);
      
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
              ...nb,
              tabs: nb.tabs.map(tab => 
                  tab.id !== activeTabId ? tab : {
                      ...tab,
                      pages: [...tab.pages, newPage],
                      activePageId: newPage.id
                  }
              )
          }
        )
      };
      setData(newData);
      setActivePageId(newPage.id);
      setEditingPageId(null);
      setEditingTabId(null);
      setEditingNotebookId(null);
      setShouldFocusTitle(false);
      showNotification('Canvas page created', 'success');
      // Trigger structure sync
      setStructureVersion(v => v + 1);
      
      // Sync to Drive if authenticated
      if (isAuthenticated && typeof GoogleAPI !== 'undefined' && activeTab?.driveFolderId) {
          try {
              const pageFileId = await GoogleAPI.syncPageToDrive(newPage, activeTab.driveFolderId);
              
              // Update local data with Drive ID
              setData(prev => ({
                  ...prev,
                  notebooks: prev.notebooks.map(nb => 
                      nb.id !== activeNotebookId ? {
                          ...nb,
                          tabs: nb.tabs.map(tab => 
                              tab.id !== activeTabId ? {
                                  ...tab,
                                  pages: tab.pages.map(page => 
                                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                                  )
                              } : tab
                          )
                      } : nb
                  )
              }));
          } catch (error) {
              console.error('Error syncing canvas page to Drive:', error);
          }
      }
    };

    const addCodePage = async () => {
      if (!activeTabId) return;
      saveToHistory();
      const newPage = createCodePage();
      const activeNotebook = data.notebooks.find(nb => nb.id === activeNotebookId);
      const activeTab = activeNotebook?.tabs.find(t => t.id === activeTabId);
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb =>
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab =>
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: [...tab.pages, newPage],
                activePageId: newPage.id
              }
            )
          }
        )
      };
      setData(newData);
      setActivePageId(newPage.id);
      setEditingPageId(null);
      setEditingTabId(null);
      setEditingNotebookId(null);
      setShouldFocusTitle(false);
      showNotification('Code page created', 'success');
      setStructureVersion(v => v + 1);
      if (isAuthenticated && typeof GoogleAPI !== 'undefined' && activeTab?.driveFolderId) {
        try {
          const pageFileId = await GoogleAPI.syncPageToDrive(newPage, activeTab.driveFolderId);
          setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb =>
              nb.id !== activeNotebookId ? {
                ...nb,
                tabs: nb.tabs.map(tab =>
                  tab.id !== activeTabId ? {
                    ...tab,
                    pages: tab.pages.map(page =>
                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                    )
                  } : tab
                )
              } : nb
            )
          }));
        } catch (error) {
          console.error('Error syncing code page to Drive:', error);
        }
      }
    };

    const addDatabasePage = async () => {
      if (!activeTabId) return;
      saveToHistory();
      const newPage = createDatabasePage();
      const activeNotebook = data.notebooks.find(nb => nb.id === activeNotebookId);
      const activeTab = activeNotebook?.tabs.find(t => t.id === activeTabId);
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb =>
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab =>
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: [...tab.pages, newPage],
                activePageId: newPage.id
              }
            )
          }
        )
      };
      setData(newData);
      setActivePageId(newPage.id);
      setEditingPageId(null);
      setEditingTabId(null);
      setEditingNotebookId(null);
      setShouldFocusTitle(false);
      showNotification('Database page created', 'success');
      setStructureVersion(v => v + 1);
      if (isAuthenticated && typeof GoogleAPI !== 'undefined' && activeTab?.driveFolderId) {
        try {
          const pageFileId = await GoogleAPI.syncPageToDrive(newPage, activeTab.driveFolderId);
          setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb =>
              nb.id !== activeNotebookId ? {
                ...nb,
                tabs: nb.tabs.map(tab =>
                  tab.id !== activeTabId ? {
                    ...tab,
                    pages: tab.pages.map(page =>
                      page.id === newPage.id ? { ...page, driveFileId: pageFileId } : page
                    )
                  } : tab
                )
              } : nb
            )
          }));
        } catch (error) {
          console.error('Error syncing database page to Drive:', error);
        }
      }
    };

    // Add a page from a Google Drive URL
    const addGooglePageFromUrl = (url) => {
      if (!activeTabId || !url) return false;
      
      // Parse Google Drive URLs to extract file ID and type
      let fileId = null;
      let pageType = 'drive';
      let icon = 'ðŸ“';
      let typeName = 'File';
      
      // Match various Google URLs
      const docMatch = url.match(/docs\.google\.com\/document\/d\/([a-zA-Z0-9-_]+)/);
      const sheetMatch = url.match(/docs\.google\.com\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
      const slideMatch = url.match(/docs\.google\.com\/presentation\/d\/([a-zA-Z0-9-_]+)/);
      const driveMatch = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9-_]+)/);
      const openMatch = url.match(/drive\.google\.com\/open\?id=([a-zA-Z0-9-_]+)/);
      
      if (docMatch) {
        fileId = docMatch[1];
        pageType = 'doc';
        icon = 'ðŸ“„';
        typeName = 'Doc';
      } else if (sheetMatch) {
        fileId = sheetMatch[1];
        pageType = 'sheet';
        icon = 'ðŸ“Š';
        typeName = 'Sheet';
      } else if (slideMatch) {
        fileId = slideMatch[1];
        pageType = 'slide';
        icon = 'ðŸ“½ï¸';
        typeName = 'Slides';
      } else if (driveMatch) {
        fileId = driveMatch[1];
      } else if (openMatch) {
        fileId = openMatch[1];
      }
      
      if (!fileId) {
        showNotification('Could not parse Google Drive URL', 'error');
        return false;
      }
      
      // Build embed URL based on type (default to edit mode for Google docs)
      let embedUrl;
      if (pageType === 'doc') {
        embedUrl = `https://docs.google.com/document/d/${fileId}/edit`;
      } else if (pageType === 'sheet') {
        embedUrl = `https://docs.google.com/spreadsheets/d/${fileId}/edit`;
      } else if (pageType === 'slide') {
        embedUrl = `https://docs.google.com/presentation/d/${fileId}/edit`;
      } else {
        // Generic Drive files stay at preview (can't be edited inline)
        embedUrl = `https://drive.google.com/file/d/${fileId}/preview`;
      }
      
      saveToHistory();
      const newPage = {
        id: generateId(),
        name: `Google ${typeName}`,
        type: pageType,
        embedUrl,
        driveFileId: fileId,
        webViewLink: url,
        icon,
        createdAt: Date.now()
      };
      
      setData(prev => ({
        ...prev,
        notebooks: prev.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab => 
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: [...tab.pages, newPage],
                activePageId: newPage.id
              }
            )
          }
        )
      }));
      
      setActivePageId(newPage.id);
      setStructureVersion(v => v + 1);
      showNotification(`Google ${typeName} added`, 'success');
      return true;
    };

    // Add a page from Google Drive Picker
    const addGooglePage = (file) => {
      if (!activeTabId || !file) return;
      
      // Determine type and icon based on MIME type
      let icon, typeName, pageType;
      const mimeType = file.mimeType;
      
      if (mimeType === 'application/vnd.google-apps.document') {
        icon = 'ðŸ“„';
        typeName = 'Doc';
        pageType = 'doc';
      } else if (mimeType === 'application/vnd.google-apps.spreadsheet') {
        icon = 'ðŸ“Š';
        typeName = 'Sheet';
        pageType = 'sheet';
      } else if (mimeType === 'application/vnd.google-apps.presentation') {
        icon = 'ðŸ“½ï¸';
        typeName = 'Slides';
        pageType = 'slide';
      } else if (mimeType === 'application/pdf') {
        icon = 'ðŸ“‘';
        typeName = 'PDF';
        pageType = 'pdf';
      } else {
        // Generic Drive file
        icon = 'ðŸ“';
        typeName = 'File';
        pageType = 'drive';
      }
      
      // Build embed URL based on type (default to edit mode for Google docs)
      let embedUrl;
      if (pageType === 'doc') {
        embedUrl = `https://docs.google.com/document/d/${file.id}/edit`;
      } else if (pageType === 'sheet') {
        embedUrl = `https://docs.google.com/spreadsheets/d/${file.id}/edit`;
      } else if (pageType === 'slide') {
        embedUrl = `https://docs.google.com/presentation/d/${file.id}/edit`;
      } else {
        // Generic Drive files stay at preview (can't be edited inline)
        embedUrl = `https://drive.google.com/file/d/${file.id}/preview`;
      }
      
      saveToHistory();
      const newPage = {
        id: generateId(),
        name: file.name || `Google ${typeName}`,
        type: pageType,
        embedUrl,
        driveFileId: file.id,
        webViewLink: file.webViewLink || file.url,
        mimeType: file.mimeType,
        icon,
        createdAt: Date.now()
      };
      
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab => 
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: [...tab.pages, newPage],
                activePageId: newPage.id
              }
            )
          }
        )
      };
      
      setData(newData);
      setActivePageId(newPage.id);
      showNotification(`${file.name || 'Google ' + typeName} added`, 'success');
    };

    const handleUrlImport = () => {
      if (!activeTabId || !urlImportValue) return;
      
      // Auto-correct URL: add https:// if missing
      let url = urlImportValue.trim();
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }
      
      let embedUrl;
      
      // Check if it's a Google Drive sharing URL
      const driveMatch = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
      if (driveMatch) {
        // Convert Google Drive sharing URL to preview embed
        const fileId = driveMatch[1];
        embedUrl = `https://drive.google.com/file/d/${fileId}/preview`;
      } else {
        // Use Google's PDF viewer for direct PDF URLs
        embedUrl = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodeURIComponent(url)}`;
      }
      
      saveToHistory();
      const newPage = {
        id: generateId(),
        name: 'PDF Document',
        type: 'pdf',
        embedUrl,
        originalUrl: url, // Store corrected URL for reference
        icon: 'ðŸ“‘',
        createdAt: Date.now()
      };
      
      const newData = {
        ...data,
        notebooks: data.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab => 
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: [...tab.pages, newPage],
                activePageId: newPage.id
              }
            )
          }
        )
      };
      
      setData(newData);
      setActivePageId(newPage.id);
      setShowUrlImport(false);
      setUrlImportValue('');
      showNotification('PDF Document added', 'success');
    };

    const openEditEmbed = () => {
      if (!activePage || !activePage.embedUrl) return;
      setEditEmbedName(activePage.name);
      setEditEmbedUrl(activePage.originalUrl || activePage.embedUrl);
      // Determine current view mode from embedUrl
      const isPreview = activePage.embedUrl.includes('/preview');
      setEditEmbedViewMode(isPreview ? 'preview' : 'edit');
      setShowEditEmbed(true);
    };

    const handleSaveEmbed = () => {
      if (!activePage || !editEmbedUrl) return;
      
      // Auto-correct URL
      let url = editEmbedUrl.trim();
      if (url && !url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }
      
      // Calculate new embed URL based on page type (keep current view mode)
      let newEmbedUrl = activePage.embedUrl;
      const pageType = activePage.type;
      const currentViewMode = activePage.embedUrl.includes('/preview') ? 'preview' : 'edit';
      
      if (pageType === 'web') {
        newEmbedUrl = url || activePage.embedUrl;
      } else if (pageType === 'pdf') {
        if (url && url !== (activePage.originalUrl || activePage.embedUrl)) {
          // Check if it's a Google Drive URL
          const driveMatch = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
          if (driveMatch) {
            newEmbedUrl = `https://drive.google.com/file/d/${driveMatch[1]}/preview`;
          } else {
            newEmbedUrl = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodeURIComponent(url)}`;
          }
        }
      } else if (['doc', 'sheet', 'slide'].includes(pageType)) {
        // Extract document ID from current or new URL
        const sourceUrl = url || activePage.originalUrl || activePage.embedUrl;
        const match = sourceUrl.match(/\/d\/([a-zA-Z0-9-_]+)/);
        if (match) {
          const docId = match[1];
          if (pageType === 'doc') {
            newEmbedUrl = `https://docs.google.com/document/d/${docId}/${currentViewMode}`;
          } else if (pageType === 'sheet') {
            newEmbedUrl = `https://docs.google.com/spreadsheets/d/${docId}/${currentViewMode}`;
          } else if (pageType === 'slide') {
            newEmbedUrl = `https://docs.google.com/presentation/d/${docId}/${currentViewMode}`;
          }
        }
      }
      
      setData(prev => ({
        ...prev,
        notebooks: prev.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab => 
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: tab.pages.map(p => 
                  p.id !== activePage.id ? p : {
                    ...p,
                    embedUrl: newEmbedUrl,
                    originalUrl: url || p.originalUrl
                  }
                )
              }
            )
          }
        )
      }));
      
      setShowEditEmbed(false);
      showNotification('Page updated', 'success');
    };

    // Handle inline URL change from header bar input
    const handleInlineUrlChange = (newUrl) => {
      if (!activePage || !newUrl) return;
      
      // Auto-correct URL
      let url = newUrl.trim();
      if (url && !url.startsWith('http://') && !url.startsWith('https://')) {
        url = 'https://' + url;
      }
      
      // Skip if URL hasn't changed
      if (url === (activePage.originalUrl || activePage.embedUrl)) return;
      
      // Calculate new embed URL based on page type (keep current view mode)
      let newEmbedUrl = activePage.embedUrl;
      const pageType = activePage.type;
      const currentViewMode = activePage.embedUrl.includes('/preview') ? 'preview' : 'edit';
      
      if (pageType === 'web') {
        newEmbedUrl = url;
      } else if (pageType === 'pdf') {
        const driveMatch = url.match(/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/);
        if (driveMatch) {
          newEmbedUrl = `https://drive.google.com/file/d/${driveMatch[1]}/preview`;
        } else {
          newEmbedUrl = `https://drive.google.com/viewerng/viewer?embedded=true&url=${encodeURIComponent(url)}`;
        }
      } else if (['doc', 'sheet', 'slide'].includes(pageType)) {
        const match = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
        if (match) {
          const docId = match[1];
          if (pageType === 'doc') {
            newEmbedUrl = `https://docs.google.com/document/d/${docId}/${currentViewMode}`;
          } else if (pageType === 'sheet') {
            newEmbedUrl = `https://docs.google.com/spreadsheets/d/${docId}/${currentViewMode}`;
          } else if (pageType === 'slide') {
            newEmbedUrl = `https://docs.google.com/presentation/d/${docId}/${currentViewMode}`;
          }
        }
      }
      
      setData(prev => ({
        ...prev,
        notebooks: prev.notebooks.map(nb => 
          nb.id !== activeNotebookId ? nb : {
            ...nb,
            tabs: nb.tabs.map(tab => 
              tab.id !== activeTabId ? tab : {
                ...tab,
                pages: tab.pages.map(p => 
                  p.id !== activePage.id ? p : {
                    ...p,
                    embedUrl: newEmbedUrl,
                    originalUrl: url
                  }
                )
              }
            )
          }
        )
      }));
      
      showNotification('URL updated', 'success');
    };

    const addBlock = (type, initialData = {}) => {
        if (!activePage) return;
        const newBlock = { id: generateId(), type, content: '', url: '', ...initialData };
        const newRow = { id: generateId(), columns: [{ id: generateId(), blocks: [newBlock] }] };
        updatePageContent([...rowsForEditor, newRow], true);
        setShowAddMenu(false);
        setAutoFocusId(newBlock.id);
    };

    const updateTabColor = (tabId, color) => {
        const newData = {
          ...data,
          notebooks: data.notebooks.map(nb => 
            nb.id !== activeNotebookId ? nb : {
              ...nb,
              tabs: nb.tabs.map(tab => tab.id !== tabId ? tab : { ...tab, color })
            }
          )
        };
        setData(newData);
        setActiveTabMenu(null);
    };

    const updateNotebookIcon = (notebookId, icon) => {
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => 
                nb.id === notebookId ? { ...nb, icon } : nb
            )
        }));
        setNotebookIconPicker(null);
    };

    const updateTabIcon = (tabId, icon) => {
        setData(prev => ({
            ...prev,
            notebooks: prev.notebooks.map(nb => 
                nb.id !== activeNotebookId ? nb : {
                    ...nb,
                    tabs: nb.tabs.map(tab => tab.id === tabId ? { ...tab, icon } : tab)
                }
            )
        }));
        setTabIconPicker(null);
    };

    // Update local state only (for responsive typing) - NO Drive API calls
    const updateLocalName = (type, id, newName) => {
        setData(prev => {
            const next = JSON.parse(JSON.stringify(prev));
            next.notebooks.forEach(nb => {
                if (type === 'notebook' && nb.id === id) {
                    nb.name = newName;
                }
                nb.tabs.forEach(tab => {
                    if (type === 'tab' && tab.id === id) {
                        tab.name = newName;
                    }
                    tab.pages.forEach(pg => {
                        if (pg.id === id) {
                            pg.name = newName;
                        }
                    });
                });
            });
            return next;
        });
    };

    // Sync rename to Drive - called on blur (when editing is finished)
    const syncRenameToDrive = async (type, id) => {
        if (!isAuthenticated || typeof GoogleAPI === 'undefined') return;
        
        // Find the item and sync its name to Drive
        for (const nb of data.notebooks) {
            if (type === 'notebook' && nb.id === id && nb.driveFolderId) {
                try {
                    await GoogleAPI.renameDriveItem(nb.driveFolderId, GoogleAPI.sanitizeFileName(nb.name));
                } catch (err) {
                    console.error('Error updating notebook folder:', err);
                }
                setStructureVersion(v => v + 1);
                return;
            }
            for (const tab of nb.tabs) {
                if (type === 'tab' && tab.id === id && tab.driveFolderId) {
                    try {
                        await GoogleAPI.renameDriveItem(tab.driveFolderId, GoogleAPI.sanitizeFileName(tab.name));
                    } catch (err) {
                        console.error('Error updating tab folder:', err);
                    }
                    setStructureVersion(v => v + 1);
                    return;
                }
                for (const pg of tab.pages) {
                    if (pg.id === id) {
                        // For block pages: rename the JSON file
                        if (pg.driveFileId) {
                            try {
                                await GoogleAPI.renameDriveItem(pg.driveFileId, GoogleAPI.sanitizeFileName(pg.name) + '.json');
                            } catch (err) {
                                console.error('Error updating page file:', err);
                            }
                        }
                        // For Google pages: rename the shortcut
                        if (pg.driveShortcutId) {
                            try {
                                await GoogleAPI.renameDriveItem(pg.driveShortcutId, pg.name);
                            } catch (err) {
                                console.error('Error updating page shortcut:', err);
                            }
                        }
                        setStructureVersion(v => v + 1);
                        return;
                    }
                }
            }
        }
    };

    // Legacy function for compatibility - just calls updateLocalName
    const renameItem = (type, id, newName) => {
        updateLocalName(type, id, newName);
    }

    const initiateDelete = (type, id) => setItemToDelete({ type, id });

    const executeDelete = async (type, id) => {
        saveToHistory();
        const newData = JSON.parse(JSON.stringify(data));
        let nextId = null;
        let driveItemsToDelete = []; // Can be multiple items for pages

        if(type === 'notebook') {
             const notebook = newData.notebooks.find(n => n.id === id);
             if (notebook?.driveFolderId) driveItemsToDelete.push(notebook.driveFolderId);
             const idx = newData.notebooks.findIndex(n => n.id === id);
             if (activeNotebookId === id) {
                 if (idx < newData.notebooks.length - 1) nextId = newData.notebooks[idx + 1].id;
                 else if (idx > 0) nextId = newData.notebooks[idx - 1].id;
             }
             newData.notebooks = newData.notebooks.filter(n => n.id !== id);
             if (activeNotebookId === id) {
                 setActiveNotebookId(nextId);
                 // Also select the appropriate tab and page in the next notebook
                 if (nextId) {
                     const nextNb = newData.notebooks.find(n => n.id === nextId);
                     if (nextNb && nextNb.tabs.length > 0) {
                         const tabToSelect = nextNb.activeTabId || nextNb.tabs[0]?.id;
                         if (tabToSelect) {
                             setActiveTabId(tabToSelect);
                             const tabObj = nextNb.tabs.find(t => t.id === tabToSelect);
                             const pageToSelect = tabObj?.activePageId || tabObj?.pages[0]?.id;
                             if (pageToSelect) setActivePageId(pageToSelect);
                             else setActivePageId(null);
                         } else {
                             setActiveTabId(null);
                             setActivePageId(null);
                         }
                     } else {
                         setActiveTabId(null);
                         setActivePageId(null);
                     }
                 } else {
                     setActiveTabId(null);
                     setActivePageId(null);
                 }
             }
        } else {
             for (let nb of newData.notebooks) {
                 if (nb.id !== activeNotebookId) continue;
                 if (type === 'tab') {
                     const tab = nb.tabs.find(t => t.id === id);
                     if (tab?.driveFolderId) driveItemsToDelete.push(tab.driveFolderId);
                     const idx = nb.tabs.findIndex(t => t.id === id);
                     if (activeTabId === id) {
                         if (idx < nb.tabs.length - 1) nextId = nb.tabs[idx + 1].id;
                         else if (idx > 0) nextId = nb.tabs[idx - 1].id;
                     }
                     nb.tabs = nb.tabs.filter(t => t.id !== id);
                     if (activeTabId === id) {
                         selectTab(nextId);
                     }
                 } else if (type === 'page') {
                     for (let tab of nb.tabs) {
                         if (tab.id !== activeTabId) continue;
                         const page = tab.pages.find(p => p.id === id);
                         // For block pages: delete the JSON file
                         if (page?.driveFileId) driveItemsToDelete.push(page.driveFileId);
                         // For Google pages: delete only the shortcut (not the original file)
                         if (page?.driveShortcutId) driveItemsToDelete.push(page.driveShortcutId);
                         const idx = tab.pages.findIndex(p => p.id === id);
                         if (activePageId === id) {
                             if (idx < tab.pages.length - 1) nextId = tab.pages[idx + 1].id;
                             else if (idx > 0) nextId = tab.pages[idx - 1].id;
                         }
                         tab.pages = tab.pages.filter(p => p.id !== id);
                         if (activePageId === id) {
                             selectPage(nextId);
                             if (nextId) shouldFocusPageRef.current = true;
                         }
                     }
                 }
             }
        }
        
        // Delete Drive items (folders, docs, or shortcuts) if authenticated
        if (isAuthenticated && typeof GoogleAPI !== 'undefined' && driveItemsToDelete.length > 0) {
            for (const itemId of driveItemsToDelete) {
                try {
                    await GoogleAPI.deleteDriveItem(itemId);
                } catch (error) {
                    console.error('Error deleting Drive item:', error);
                    // Continue with local delete even if Drive delete fails
                }
            }
        }
        
        setData(newData);
        if (itemToDelete && itemToDelete.id === id) setItemToDelete(null);
        if (activeTabMenu && activeTabMenu.id === id) setActiveTabMenu(null);
        if (selectedBlockId === id) setSelectedBlockId(null);
        showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} deleted`, 'success');
        // Trigger structure sync for deletion
        setStructureVersion(v => v + 1);
    }

    const confirmDelete = () => {
        if (!itemToDelete) return;
        executeDelete(itemToDelete.type, itemToDelete.id);
    }

    const handleNavDragStart = (e, type, id, index) => {
        e.dataTransfer.setData('nav_drag', JSON.stringify({ type, id, index }));
    };

    const handleNavDrop = (e, type, targetIndex) => {
        e.preventDefault(); e.stopPropagation();
        const dragDataRaw = e.dataTransfer.getData('nav_drag');
        if (!dragDataRaw) return;
        const dragData = JSON.parse(dragDataRaw);
        if (dragData.type !== type || dragData.index === targetIndex) return;

        saveToHistory();
        const newData = JSON.parse(JSON.stringify(data));
        if (type === 'notebook') {
            const item = newData.notebooks.splice(dragData.index, 1)[0];
            newData.notebooks.splice(targetIndex, 0, item);
        } else if (type === 'tab') {
            const nb = newData.notebooks.find(n => n.id === activeNotebookId);
            if (nb) {
                const item = nb.tabs.splice(dragData.index, 1)[0];
                nb.tabs.splice(targetIndex, 0, item);
            }
        } else if (type === 'page') {
            const nb = newData.notebooks.find(n => n.id === activeNotebookId);
            const tab = nb?.tabs.find(t => t.id === activeTabId);
            if (tab) {
                const item = tab.pages.splice(dragData.index, 1)[0];
                tab.pages.splice(targetIndex, 0, item);
            }
        }
        setData(newData);
    };

    const handleDragStart = (e, block, rowId, colId) => {
        e.dataTransfer.setData('block_drag', JSON.stringify({ block, rowId, colId }));
        setDraggedBlock({ block, rowId, colId });
    };

    const handleDrop = (e) => {
        e.preventDefault();
        if (!draggedBlock || !dropTarget) { setDraggedBlock(null); setDropTarget(null); return; }
        const { block } = draggedBlock;
        const { rowId: tgtRowId, colId: tgtColId, blockId: tgtBlockId, position } = dropTarget;

        let newRows = JSON.parse(JSON.stringify(rowsForEditor));
        let movedBlock = null;

        // Remove the dragged block from its original position
        newRows.forEach(row => { row.columns.forEach(col => { const idx = col.blocks.findIndex(b => b.id === block.id); if (idx > -1) { movedBlock = col.blocks[idx]; col.blocks.splice(idx, 1); } }); });
        newRows.forEach(row => { row.columns = row.columns.filter(c => c.blocks.length > 0); });
        newRows = newRows.filter(r => r.columns.length > 0);

        if (movedBlock) {
            if (position === 'left' || position === 'right') {
                // Find the target row and column
                const targetRowIndex = newRows.findIndex(r => r.id === tgtRowId);
                if (targetRowIndex > -1) {
                    const targetRow = newRows[targetRowIndex];
                    const targetColIndex = targetRow.columns.findIndex(c => c.id === tgtColId);
                    const targetCol = targetRow.columns[targetColIndex];
                    
                    if (targetCol) {
                        const targetBlockIndex = targetCol.blocks.findIndex(b => b.id === tgtBlockId);
                        
                        // Check if this column has multiple blocks
                        if (targetCol.blocks.length > 1) {
                            // Split the row: extract just the target block into a new row with columns
                            const blocksAbove = targetCol.blocks.slice(0, targetBlockIndex);
                            const targetBlock = targetCol.blocks[targetBlockIndex];
                            const blocksBelow = targetCol.blocks.slice(targetBlockIndex + 1);
                            
                            // Create new rows
                            const rowsToInsert = [];
                            
                            // Row for blocks above (if any)
                            if (blocksAbove.length > 0) {
                                rowsToInsert.push({ id: generateId(), columns: [{ id: generateId(), blocks: blocksAbove }] });
                            }
                            
                            // Row with the two-column arrangement
                            const col1 = { id: generateId(), blocks: [position === 'left' ? movedBlock : targetBlock] };
                            const col2 = { id: generateId(), blocks: [position === 'left' ? targetBlock : movedBlock] };
                            rowsToInsert.push({ id: generateId(), columns: [col1, col2] });
                            
                            // Row for blocks below (if any)
                            if (blocksBelow.length > 0) {
                                rowsToInsert.push({ id: generateId(), columns: [{ id: generateId(), blocks: blocksBelow }] });
                            }
                            
                            // Remove the original column/row and insert new rows
                            targetCol.blocks = [];
                            newRows.forEach(row => { row.columns = row.columns.filter(c => c.blocks.length > 0); });
                            newRows = newRows.filter(r => r.columns.length > 0);
                            
                            // Find where to insert (the old row index, adjusted for filtering)
                            const insertIndex = targetRowIndex <= newRows.length ? targetRowIndex : newRows.length;
                            newRows.splice(insertIndex, 0, ...rowsToInsert);
                        } else {
                            // Single block in column - can add column directly if under max
                            if (targetRow.columns.length < settings.maxColumns) {
                                const newCol = { id: generateId(), blocks: [movedBlock] };
                                if (position === 'left') targetRow.columns.splice(targetColIndex, 0, newCol);
                                else targetRow.columns.splice(targetColIndex + 1, 0, newCol);
                            } else {
                                // Max columns reached - add to the column instead
                                targetCol.blocks.push(movedBlock);
                            }
                        }
                    }
                }
            } else {
                // Top/bottom drop - add to existing column
                const targetRow = newRows.find(r => r.id === tgtRowId);
                const targetCol = targetRow?.columns.find(c => c.id === tgtColId);
                if (targetCol) {
                    const targetBlockIndex = targetCol.blocks.findIndex(b => b.id === tgtBlockId);
                    const insertIndex = position === 'top' ? targetBlockIndex : targetBlockIndex + 1;
                    targetCol.blocks.splice(insertIndex, 0, movedBlock);
                }
            }
        }
        updatePageContent(newRows, true);
        setDraggedBlock(null); setDropTarget(null);
    };

    const getTabColorClasses = (colorName, isActive) => {
        // Inactive tab colors - pastel in light mode, darker in dark mode
        const colors = {
            gray: 'bg-gray-100 hover:bg-gray-200 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200',
            red: 'bg-red-100 hover:bg-red-200 text-red-800 dark:bg-red-900 dark:hover:bg-red-800 dark:text-red-200',
            orange: 'bg-orange-100 hover:bg-orange-200 text-orange-800 dark:bg-orange-900 dark:hover:bg-orange-800 dark:text-orange-200',
            amber: 'bg-amber-100 hover:bg-amber-200 text-amber-800 dark:bg-amber-900 dark:hover:bg-amber-800 dark:text-amber-200',
            green: 'bg-green-100 hover:bg-green-200 text-green-800 dark:bg-green-900 dark:hover:bg-green-800 dark:text-green-200',
            teal: 'bg-teal-100 hover:bg-teal-200 text-teal-800 dark:bg-teal-900 dark:hover:bg-teal-800 dark:text-teal-200',
            blue: 'bg-blue-100 hover:bg-blue-200 text-blue-800 dark:bg-blue-900 dark:hover:bg-blue-800 dark:text-blue-200',
            indigo: 'bg-indigo-100 hover:bg-indigo-200 text-indigo-800 dark:bg-indigo-900 dark:hover:bg-indigo-800 dark:text-indigo-200',
            purple: 'bg-purple-100 hover:bg-purple-200 text-purple-800 dark:bg-purple-900 dark:hover:bg-purple-800 dark:text-purple-200',
            pink: 'bg-pink-100 hover:bg-pink-200 text-pink-800 dark:bg-pink-900 dark:hover:bg-pink-800 dark:text-pink-200',
        };
        // Active tab colors - solid colors (same in both modes)
        const activeColors = {
             gray: 'bg-gray-500 text-white', red: 'bg-red-500 text-white', orange: 'bg-orange-500 text-white',
             amber: 'bg-amber-500 text-white', green: 'bg-green-600 text-white', teal: 'bg-teal-600 text-white',
             blue: 'bg-blue-600 text-white', indigo: 'bg-indigo-600 text-white', purple: 'bg-purple-600 text-white',
             pink: 'bg-pink-600 text-white',
        };
        return isActive ? activeColors[colorName] : colors[colorName];
    };

    const getPageBgClass = (colorName) => {
         const map = {
            gray: 'bg-gray-100 dark:bg-gray-800',
            red: 'bg-red-100 dark:bg-red-900',
            orange: 'bg-orange-100 dark:bg-orange-900',
            amber: 'bg-amber-100 dark:bg-amber-900',
            green: 'bg-green-100 dark:bg-green-900',
            teal: 'bg-teal-100 dark:bg-teal-900',
            blue: 'bg-blue-100 dark:bg-blue-900',
            indigo: 'bg-indigo-100 dark:bg-indigo-900',
            purple: 'bg-purple-100 dark:bg-purple-900',
            pink: 'bg-pink-100 dark:bg-pink-900',
         }
         return map[colorName] || 'bg-white dark:bg-gray-900';
    }

    const updateBlockColor = (blockId, colorName) => {
        handleUpdateBlock(blockId, { backgroundColor: colorName });
        setBlockMenu(null);
    }

    const findBlockInRows = (rows, blockId) => {
        if (!rows || !rows.length) return null;
        for (const row of rows) {
            for (const col of row.columns) {
                const b = col.blocks.find(block => block.id === blockId);
                if (b) return b;
            }
        }
        return null;
    };

    const changeBlockType = (blockId, newType) => {
        const block = findBlockInRows(rowsForEditor, blockId);
        if (!block) { setBlockMenu(null); return; }
        const cur = block.type;
        const curContent = block.content || '';
        const curUrl = block.url || '';
        const textLike = ['text', 'h1', 'h2', 'h3', 'h4', 'ul', 'ol', 'todo', 'link'];
        const isTextLike = (t) => textLike.includes(t);
        const mediaStructural = ['image', 'video', 'divider', 'gdoc'];

        const updates = { type: newType };

        if (mediaStructural.includes(newType)) {
            updates.content = '';
            updates.url = '';
            if (newType === 'gdoc') {
                updates.driveFileId = null;
                updates.webViewLink = null;
                updates.mimeType = null;
            }
        } else {
            updates.url = newType === 'link' ? curUrl : '';
            updates.checked = newType === 'todo' ? (cur === 'todo' ? (block.checked === true) : false) : false;
            if (isTextLike(cur) && isTextLike(newType)) {
                if (['ul', 'ol'].includes(cur) && !['ul', 'ol'].includes(newType)) {
                    const div = document.createElement('div');
                    div.innerHTML = curContent;
                    updates.content = (div.innerText || '').trim();
                } else if (!['ul', 'ol'].includes(cur) && ['ul', 'ol'].includes(newType)) {
                    const div = document.createElement('div');
                    div.innerHTML = curContent;
                    const plainText = (div.innerText || '').trim();
                    updates.content = plainText ? `<li>${plainText}</li>` : '<li></li>';
                } else {
                    // Preserve full list HTML (all <li> items) when switching between ul and ol.
                    updates.content = curContent;
                }
            } else if (isTextLike(cur) && newType === 'link') {
                updates.content = curContent;
                updates.url = curUrl;
            } else {
                updates.content = '';
            }
        }

        if (newType !== 'gdoc') {
            updates.driveFileId = null;
            updates.webViewLink = null;
            updates.mimeType = null;
        }

        handleUpdateBlock(blockId, updates);
        setBlockMenu(null);
        setAutoFocusId(blockId);
    }

    const handlePageKeyDown = (e, pageId, index, pages) => {
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (index < pages.length - 1) { selectPage(pages[index + 1].id); shouldFocusPageRef.current = true; }
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (index > 0) { selectPage(pages[index - 1].id); shouldFocusPageRef.current = true; }
        } else if (e.key === 'Delete') {
            e.preventDefault(); executeDelete('page', pageId);
        }
    };

    const handleTitleKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            e.target.blur();
            if (rowsForEditor.length > 0 && rowsForEditor[0].columns.length > 0 && rowsForEditor[0].columns[0].blocks.length > 0) {
                setAutoFocusId(rowsForEditor[0].columns[0].blocks[0].id);
            } else {
                // If page is empty, create a new text block
                addBlock('text');
            }
        }
    };

    return (
      <div className="flex h-screen w-full bg-gray-50 overflow-hidden font-sans text-sm">
        {/* NOTEBOOKS SIDEBAR - Always dark */}
        <div className={`${settings.condensedView ? 'w-16' : 'w-64'} flex-shrink-0 flex flex-col border-r border-gray-700 bg-gray-900 text-gray-300 transition-all duration-200`}>
          <div className={`p-4 border-b border-gray-800 flex items-center ${settings.condensedView ? 'justify-center' : 'justify-between'}`}>
              {!settings.condensedView && <span className="font-bold text-white flex items-center gap-2 text-lg"><Book size={18}/> Strata</span>}
              <button onClick={addNotebook} className="hover:bg-gray-800 p-1 rounded transition-colors" title="Add notebook"><Plus size={18} /></button>
          </div>
          <div className="flex-1 min-h-0 min-w-0 overflow-y-auto overflow-x-hidden p-2 space-y-1">
            {/* Favorites Section - Collapsible */}
            {getStarredPages().length > 0 && (
              <div className="mb-2">
                <button 
                  onClick={() => setFavoritesExpanded(!favoritesExpanded)}
                  className={`w-full flex items-center ${settings.condensedView ? 'justify-center' : 'gap-2'} px-2 py-1.5 text-yellow-400 hover:bg-gray-800 rounded transition-colors`}
                >
                  <ChevronRight size={14} className={`transition-transform ${favoritesExpanded ? 'rotate-90' : ''} ${settings.condensedView ? 'hidden' : ''}`} />
                  <Star size={14} filled />
                  {!settings.condensedView && (
                    <>
                      <span className="text-xs font-semibold uppercase tracking-wider">Favorites</span>
                      <span className="text-xs text-gray-500 ml-auto">{getStarredPages().length}</span>
                    </>
                  )}
                </button>
                {favoritesExpanded && getStarredPages().map(page => (
                  <div 
                    key={`fav-${page.id}`}
                    onClick={() => {
                      setActiveNotebookId(page.notebookId);
                      setActiveTabId(page.tabId);
                      setActivePageId(page.id);
                    }}
                    className={`flex items-center ${settings.condensedView ? 'justify-center' : 'gap-2 ml-4'} px-3 py-1.5 rounded cursor-pointer transition-colors hover:bg-gray-800 ${activePageId === page.id ? 'bg-gray-800 text-white' : ''}`}
                    title={settings.condensedView ? `${page.name} (${page.notebookName} / ${page.tabName})` : undefined}
                  >
                    <span className="text-sm">{page.icon || 'ðŸ“„'}</span>
                    {!settings.condensedView && (
                      <div className="flex-1 min-w-0">
                        <div className="text-sm truncate">{page.name}</div>
                        <div className="text-xs text-gray-500 truncate">{page.notebookName} / {page.tabName}</div>
                      </div>
                    )}
                  </div>
                ))}
                <div className="border-b border-gray-700 my-2"></div>
              </div>
            )}
            
            {data.notebooks.map((nb, index) => (
              <div key={nb.id} className="group flex min-w-0 items-center gap-2 overflow-hidden" draggable={!editingNotebookId} onDragStart={(e) => handleNavDragStart(e, 'notebook', nb.id, index)} onDragOver={(e) => e.preventDefault()} onDrop={(e) => handleNavDrop(e, 'notebook', index)} title={settings.condensedView ? nb.name : undefined}>
                   <div onClick={() => selectNotebook(nb.id)} className={`flex-1 min-w-0 flex items-center ${settings.condensedView ? 'justify-center' : 'gap-2'} px-3 py-2 rounded cursor-pointer transition-all ${activeNotebookId === nb.id ? 'bg-gray-800 text-white font-medium border-l-2 border-l-blue-500' : 'hover:bg-gray-800 border-l-2 border-l-transparent'}`}>
                      <span 
                          className={`${settings.condensedView ? 'text-xl' : 'text-base'} ${activeNotebookId === nb.id && !settings.condensedView ? 'cursor-pointer hover:bg-gray-700' : ''} rounded px-0.5 notebook-icon-trigger`} 
                          onClick={(e) => { 
                              if (activeNotebookId !== nb.id) return; // Only active notebook
                              if (settings.condensedView) return; // Don't open picker in condensed view
                              e.stopPropagation(); 
                              const rect = e.currentTarget.getBoundingClientRect();
                              setNotebookIconPicker({ id: nb.id, top: rect.bottom + 5, left: rect.left });
                          }}
                      >
                          {nb.icon || 'ðŸ““'}
                      </span>
                      {!settings.condensedView && (activeNotebookId === nb.id && editingNotebookId === nb.id ? (
                          <input ref={(el) => notebookInputRefs.current[nb.id] = el} className="bg-transparent border-none outline-none w-full notebook-input" value={nb.name} onChange={(e) => updateLocalName('notebook', nb.id, e.target.value)} onClick={(e) => e.stopPropagation()} onFocus={(e) => e.target.select()} onBlur={() => { syncRenameToDrive('notebook', nb.id); if (!creationFlow) setEditingNotebookId(null); }} onKeyDown={(e) => { 
                              if(e.key === 'Enter') {
                                  e.preventDefault();
                                  setEditingNotebookId(null);
                                  // If in creation flow, move to tab name editing
                                  if (creationFlow && creationFlow.notebookId === nb.id) {
                                      setEditingTabId(creationFlow.tabId);
                                  }
                              }
                              if(e.key === 'Escape') {
                                  setEditingNotebookId(null);
                                  setCreationFlow(null);
                              }
                              e.stopPropagation(); 
                          }} />
                      ) : (
                          <span className="truncate w-full" onClick={(e) => { if(activeNotebookId === nb.id) { e.stopPropagation(); setEditingNotebookId(nb.id); } }}>{nb.name}</span>
                      ))}
                  </div>
                  {!settings.condensedView && <button onClick={() => initiateDelete('notebook', nb.id)} className="opacity-0 group-hover:opacity-100 hover:text-red-400 p-1 transition-opacity"><Trash2 size={12}/></button>}
              </div>
            ))}
          </div>
          {/* Bottom toolbar */}
          <div className={`p-2 border-t border-gray-800 flex items-center justify-between`}>
              <button onClick={() => setSettings(s => ({...s, condensedView: !s.condensedView}))} className="hover:bg-gray-800 p-2 rounded transition-colors" title={settings.condensedView ? "Expand view" : "Compact view"}>
                  {settings.condensedView ? <Maximize2 size={18} /> : <Minimize2 size={18} />}
              </button>
{!settings.condensedView && (
                  <div className="flex items-center gap-2 text-xs text-gray-500">
                      <span>v{APP_VERSION}</span>
                      {isSyncing && <span className="text-blue-400 animate-pulse">âŸ³</span>}
                      {lastSyncTime && !isSyncing && <span className="text-green-500">âœ“ Synced</span>}
                  </div>
              )}
          </div>
        </div>

        <div className="flex-1 min-h-0 flex flex-col h-full min-w-0">
          {/* TABS BAR */}
          {activeNotebook ? (
               <div 
                   ref={tabBarRef}
                   className="h-12 flex-shrink-0 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-700 flex items-end px-2 overflow-x-auto no-scrollbar"
               >
               <div className="flex items-end space-x-1">
               {activeNotebook.tabs.map((tab, index) => (
                 <div 
                     key={tab.id} 
                     className="group relative flex-shrink-0" 
                     draggable={!editingTabId} 
                     onDragStart={(e) => handleNavDragStart(e, 'tab', tab.id, index)} 
                     onDragOver={(e) => e.preventDefault()} 
                     onDrop={(e) => handleNavDrop(e, 'tab', index)}
                 >
                     <div 
                         onClick={() => selectTab(tab.id)} 
                         className={`${settings.condensedView ? 'px-2' : 'px-4'} py-2 rounded-t-lg cursor-pointer flex items-center gap-2 tab-gloss overflow-hidden whitespace-nowrap transition-shadow ${activeTabId === tab.id ? `${getTabColorClasses(tab.color, true)} shadow-md -mb-px` : `${getTabColorClasses(tab.color, false)} shadow-none`}`} 
                         title={settings.condensedView ? tab.name : undefined}
                     >
                      <span 
                          className={`text-sm flex-shrink-0 ${activeTabId === tab.id && !settings.condensedView ? 'cursor-pointer hover:bg-black/10' : ''} rounded px-0.5 tab-icon-trigger`} 
                          onClick={(e) => { 
                              if (activeTabId !== tab.id) return;
                              if (settings.condensedView) return;
                              e.stopPropagation(); 
                              const rect = e.currentTarget.getBoundingClientRect();
                              setTabIconPicker({ id: tab.id, top: rect.bottom + 5, left: rect.left });
                          }}
                      >
                          {tab.icon || 'ðŸ“‹'}
                      </span>
                      {!settings.condensedView && (activeTabId === tab.id && editingTabId === tab.id ? (
                          <input ref={(el) => tabInputRefs.current[tab.id] = el} className="bg-transparent border-none outline-none w-full font-medium tab-input min-w-0" value={tab.name} onChange={(e) => updateLocalName('tab', tab.id, e.target.value)} onFocus={(e) => e.target.select()} onBlur={() => { syncRenameToDrive('tab', tab.id); if (!creationFlow) setEditingTabId(null); }} onKeyDown={(e) => { 
                              if(e.key === 'Enter') {
                                  e.preventDefault();
                                  setEditingTabId(null);
                                  if (creationFlow && creationFlow.tabId === tab.id) {
                                      setShouldFocusTitle(true);
                                      setCreationFlow(null);
                                  }
                              }
                              if(e.key === 'Escape') {
                                  setEditingTabId(null);
                                  setCreationFlow(null);
                              }
                              e.stopPropagation(); 
                          }} onClick={(e) => e.stopPropagation()} />
                      ) : (
                          <span className="truncate font-medium flex-1 min-w-0" onDoubleClick={(e) => { if(activeTabId === tab.id) { e.stopPropagation(); setEditingTabId(tab.id); } }}>{tab.name}</span>
                      ))}
                       {!settings.condensedView && activeTabId === tab.id && <div className="relative ml-auto flex-shrink-0">
                          <button className="p-1 rounded hover:bg-black/10 tab-settings-trigger opacity-100" onClick={(e) => {
                                  e.stopPropagation();
                                  if (activeTabMenu?.id === tab.id) setActiveTabMenu(null);
                                  else { const rect = e.currentTarget.getBoundingClientRect(); setActiveTabMenu({ id: tab.id, top: rect.bottom + 5, left: rect.left }); }
                              }}>
                             <Settings size={12} />
                          </button>
                       </div>}
                     </div>
                 </div>
               ))}
               </div>
               <button onClick={addTab} className="mb-2 ml-1 p-1 hover:bg-gray-200 rounded text-gray-500 transition-colors flex-shrink-0"><Plus size={18}/></button>
               {/* Header right section */}
               <div className="ml-auto flex items-center gap-2 h-full flex-shrink-0">
                   {isLoadingAuth ? (
                       <span className="text-xs text-gray-500">Loading...</span>
                   ) : isAuthenticated ? (
                       <div 
                           className="relative h-full flex items-center"
                           onMouseEnter={() => setShowAccountPopup(true)}
                           onMouseLeave={() => setShowAccountPopup(false)}
                       >
                           <div 
                               className="flex items-center justify-center gap-2 h-10 px-4 bg-gray-200 dark:bg-gray-700 rounded cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
                               onClick={() => setShowSignOutConfirm(true)}
                           >
                               <GoogleG size={16} />
                               <span className="text-sm text-gray-700 dark:text-gray-200 truncate max-w-40">{userName || userEmail}</span>
                           </div>
                           
                           {/* Hover Popup */}
                           {showAccountPopup && (
                               <div className="absolute top-full right-0 mt-1 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 p-3 text-center min-w-48 z-50 animate-fade-in">
                                   <div className="font-medium text-gray-800 dark:text-gray-200">{userName}</div>
                                   <div className="text-xs text-gray-500 dark:text-gray-400">{userEmail}</div>
                                   <div className="text-xs text-red-500 mt-2">Click to sign out</div>
                               </div>
                           )}
                       </div>
                   ) : (
                       <button onClick={handleSignIn} className="flex items-center gap-2 h-10 px-4 bg-blue-500 hover:bg-blue-600 text-white text-sm rounded transition-colors" disabled={typeof GoogleAPI === 'undefined'}>
                           <GoogleG size={16} /> Sign in with Google
                       </button>
                   )}
                   <button onClick={() => setShowSettings(true)} className="p-2 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-gray-500 dark:text-gray-400 settings-trigger transition-colors" title="Settings">
                       <Settings size={20} />
                   </button>
               </div>
             </div>
          ) : (
              <div className="h-12 bg-gray-300 dark:bg-gray-800 border-b border-gray-400 dark:border-gray-700 flex items-center px-4 text-gray-500 dark:text-gray-400">Select a notebook</div>
          )}

          <div className="flex-1 min-h-0 flex overflow-hidden">
              {/* Main content area with cached iframes */}
              <div className={`flex-1 min-h-0 relative ${(activePage?.embedUrl || activePage?.type === 'canvas' || activePage?.type === 'mermaid' || activePage?.type === 'database') ? 'p-0 overflow-hidden' : 'p-8 overflow-y-auto'} transition-colors duration-300 ${activeTab ? getPageBgClass(activeTab.color) : 'bg-gray-50'}`}>
                  {/* Session-wide cached iframes - persist across all tab/notebook switches */}
                  {data.notebooks.flatMap(nb => nb.tabs.flatMap(t => t.pages))
                      .filter(p => {
                          if (!p.embedUrl || !viewedEmbedPages.has(p.id)) return false;
                          if (activePage?.id === p.id && activePage?.embedUrl && showZoomForEmbed(activePage) && (getPageZoom(activePage.id) || 100) !== 100) return false;
                          return true;
                      })
                      .map(page => (
                          <iframe 
                              key={page.id}
                              src={page.embedUrl}
                              className={`absolute w-full border-0 ${
                                  activePage?.id === page.id && activePage?.embedUrl ? '' : 'hidden'
                              }`}
                              style={{ 
                                  top: activePage?.id === page.id ? '52px' : '0',
                                  left: 0,
                                  right: 0,
                                  height: activePage?.id === page.id ? 'calc(100% - 52px)' : '100%',
                                  width: '100%'
                              }}
                              allow="autoplay"
                          />
                      ))
                  }
                  {activePage ? (
                      activePage.type === 'canvas' ? (
                          // Canvas page
                          <CanvasPageComponent 
                            page={activePage}
                            onUpdate={(updates) => updatePageMeta(updates)}
                            saveToHistory={saveToHistory}
                            showNotification={showNotification}
                          />
                      ) : activePage.type === 'mermaid' ? (
                          <MermaidPageComponent
                            page={activePage}
                            onUpdate={(updates) => updatePageMeta(updates)}
                            saveToHistory={saveToHistory}
                            showNotification={showNotification}
                            updateLocalName={updateLocalName}
                            syncRenameToDrive={syncRenameToDrive}
                            toggleStar={toggleStar}
                            activeNotebookId={activeNotebookId}
                            activeTabId={activeTabId}
                          />
                      ) : activePage.type === 'database' ? (
                          <TablePage
                            page={activePage}
                            onUpdate={(updates) => updatePageMeta(updates)}
                          />
                      ) : activePage.embedUrl ? (
                          // Embedded page (Google Docs/Sheets/Slides, Web, PDF)
                          <div className="w-full h-full flex flex-col">
                              <div className="bg-white border-b border-gray-200 px-4 py-2 flex items-center gap-3">
                                  <span className="text-2xl">{activePage.icon}</span>
                                  {editingEmbedName ? (
                                    <input 
                                        className="font-semibold text-gray-700 outline-none border-b-2 border-blue-400 bg-transparent w-40"
                                        value={activePage.name}
                                          onChange={(e) => {
                                              setData(prev => ({
                                                  ...prev,
                                                  notebooks: prev.notebooks.map(nb => 
                                                      nb.id !== activeNotebookId ? nb : {
                                                          ...nb,
                                                          tabs: nb.tabs.map(tab => 
                                                              tab.id !== activeTabId ? tab : {
                                                                  ...tab,
                                                                  pages: tab.pages.map(p => 
                                                                      p.id !== activePage.id ? p : { ...p, name: e.target.value }
                                                                  )
                                                              }
                                                          )
                                                      }
                                                  )
                                              }));
                                          }}
                                          onBlur={() => setEditingEmbedName(false)}
                                          onKeyDown={(e) => { if (e.key === 'Enter' || e.key === 'Escape') setEditingEmbedName(false); }}
                                          autoFocus
                                      />
                                  ) : (
                                    <span 
                                        className="font-semibold text-gray-700 cursor-pointer hover:text-blue-600 transition-colors w-40 truncate"
                                        onClick={() => setEditingEmbedName(true)}
                                        title={activePage.name}
                                    >
                                        {activePage.name}
                                    </span>
                                  )}
                                  <button 
                                      onClick={() => toggleStar(activePage.id, activeNotebookId, activeTabId)}
                                      className={`p-1.5 rounded transition-colors ${activePage.starred ? 'text-yellow-400 hover:bg-yellow-50' : 'text-gray-300 hover:text-yellow-400 hover:bg-gray-100'}`}
                                      title={activePage.starred ? 'Remove from favorites' : 'Add to favorites'}
                                  >
                                      <Star size={16} filled={activePage.starred} />
                                  </button>
                                  {/* Edit/Preview Toggle Switch - Only for Google Docs/Sheets/Slides */}
                                  {['doc', 'sheet', 'slide'].includes(activePage.type) && (
                                      <div className="flex items-center gap-1.5 ml-2">
                                          <span className={`text-xs font-medium transition-colors ${!activePage.embedUrl.includes('/preview') ? 'text-blue-600' : 'text-gray-400'}`}>Edit</span>
                                          <button
                                              onClick={() => toggleViewMode(activePage.id)}
                                              className="relative w-11 h-6 rounded-full transition-colors duration-200 focus:outline-none overflow-hidden"
                                              style={{ backgroundColor: activePage.embedUrl.includes('/preview') ? '#9ca3af' : '#3b82f6' }}
                                              title={activePage.embedUrl.includes('/preview') ? 'Switch to Edit mode' : 'Switch to Preview mode'}
                                          >
                                              <span 
                                                  className={`absolute top-1 left-1 w-4 h-4 bg-white rounded-full shadow-sm transition-transform duration-200 ${
                                                      activePage.embedUrl.includes('/preview') ? 'translate-x-5' : 'translate-x-0'
                                                  }`}
                                              />
                                          </button>
                                          <span className={`text-xs font-medium transition-colors ${activePage.embedUrl.includes('/preview') ? 'text-gray-600' : 'text-gray-400'}`}>Preview</span>
                                      </div>
                                  )}
                                  {/* Zoom Controls - only for Google Docs/Sheets in preview */}
                                  {showZoomForEmbed(activePage) && (
                                  <div className="flex items-center gap-1 ml-2 border-l border-gray-200 pl-2">
                                      <button 
                                          onClick={() => setPageZoom(activePage.id, getPageZoom(activePage.id) - 25)}
                                          className="p-1 hover:bg-gray-100 rounded text-gray-500 hover:text-gray-700 disabled:opacity-30 disabled:cursor-not-allowed"
                                          disabled={getPageZoom(activePage.id) <= 25}
                                          title="Zoom out"
                                      >
                                          <Minus size={14} />
                                      </button>
                                      <span className="text-xs text-gray-600 w-10 text-center font-medium">
                                          {getPageZoom(activePage.id)}%
                                      </span>
                                      <button 
                                          onClick={() => setPageZoom(activePage.id, getPageZoom(activePage.id) + 25)}
                                          className="p-1 hover:bg-gray-100 rounded text-gray-500 hover:text-gray-700 disabled:opacity-30 disabled:cursor-not-allowed"
                                          disabled={getPageZoom(activePage.id) >= 200}
                                          title="Zoom in"
                                      >
                                          <Plus size={14} />
                                      </button>
                                  </div>
                                  )}
                                  {/* URL Field */}
                                  <div className="flex items-center gap-1 ml-2">
                                      <span className="text-xs text-gray-400">URL:</span>
                                      <input 
                                          type="text"
                                          className="text-xs text-blue-500 dark:text-blue-400 bg-transparent border-b border-transparent hover:border-blue-300 focus:border-blue-500 focus:outline-none px-1 py-0.5 w-48"
                                          defaultValue={activePage.originalUrl || activePage.embedUrl || ''}
                                          key={activePage.id}
                                          onFocus={(e) => setInlineUrlValue(e.target.value)}
                                          onBlur={(e) => {
                                              if (e.target.value !== (activePage.originalUrl || activePage.embedUrl)) {
                                                  handleInlineUrlChange(e.target.value);
                                              }
                                          }}
                                          onKeyDown={(e) => {
                                              if (e.key === 'Enter') {
                                                  e.target.blur();
                                              }
                                          }}
                                          title={activePage.originalUrl || activePage.embedUrl}
                                      />
                                  </div>
                                  <span className="text-xs text-gray-400 ml-auto">
                                      {activePage.type === 'doc' ? 'Google Docs' : 
                                       activePage.type === 'sheet' ? 'Google Sheets' : 
                                       activePage.type === 'slide' ? 'Google Slides' :
                                       activePage.type === 'web' ? 'Web Page' :
                                       activePage.type === 'pdf' ? 'PDF Document' : 'Embed'}
                                  </span>
                              </div>
                              {/* Zoom viewport (Docs/Sheets preview, zoom !== 100%) or placeholder for cached iframes */}
                              {activePage.embedUrl && showZoomForEmbed(activePage) && (getPageZoom(activePage.id) || 100) !== 100 ? (
                                  <div className="flex-1 min-h-0 w-full overflow-auto">
                                      {(() => {
                                          const zoom = getPageZoom(activePage.id) || 100;
                                          return (
                                              <div style={{ width: '100%', height: '100%' }}>
                                                  <iframe
                                                      src={activePage.embedUrl}
                                                      className="border-0 block"
                                                      style={{
                                                          width: `${10000 / zoom}%`,
                                                          height: `${10000 / zoom}%`,
                                                          transform: `scale(${zoom / 100})`,
                                                          transformOrigin: '0 0'
                                                      }}
                                                      allow="autoplay"
                                                  />
                                              </div>
                                          );
                                      })()}
                                  </div>
                              ) : (
                                  <div className="flex-1 w-full relative pointer-events-none" />
                              )}
                          </div>
                      ) : (
                      // Regular block page
                      <div className="max-w-4xl mx-auto min-h-[500px] bg-white shadow-sm border border-gray-200 rounded-lg overflow-hidden pb-10">
                          {activePage.cover && <div className="h-40 w-full bg-gray-100 group relative">
                              {activePage.cover.startsWith('color:') ? (
                                  <div className={`w-full h-full bg-${activePage.cover.replace('color:', '')}-400`} />
                              ) : activePage.cover.startsWith('gradient:') ? (
                                  <div className="w-full h-full" style={{ background: activePage.cover.replace('gradient:', '') }} />
                              ) : (
                                  <img src={activePage.cover} className="w-full h-full object-cover" />
                              )}
                              <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2">
                                  <button onClick={() => setShowCoverInput(true)} className="bg-white/80 hover:bg-white text-xs px-2 py-1 rounded shadow-sm text-gray-700 cover-input-trigger">Change Cover</button>
                                  <button onClick={() => updatePageMeta({ cover: null })} className="bg-white/80 hover:bg-white text-xs px-2 py-1 rounded shadow-sm text-red-600">Remove</button>
                              </div>
                          </div>}
                          <div className={`p-8 ${activePage.cover ? 'pt-2' : ''}`}>
                              {!activePage.cover && <div className="w-full flex justify-center opacity-0 hover:opacity-100 mb-2 transition-opacity"><button onClick={() => setShowCoverInput(true)} className="text-xs text-gray-400 hover:text-gray-600 flex items-center gap-1"><ImageIcon size={12}/> Add Cover</button></div>}
                              
                              {showCoverInput && (
                                  <div className="absolute top-20 right-1/2 translate-x-1/2 z-50 bg-white p-3 rounded-lg shadow-xl border border-gray-200 w-72 cover-input animate-fade-in">
                                      <div className="text-xs font-semibold text-gray-500 mb-2">Image URL</div>
                                      <input 
                                          className="w-full text-xs p-2 border rounded mb-3" 
                                          placeholder="Paste image URL..." 
                                          autoFocus
                                          onKeyDown={(e) => {
                                              if (e.key === 'Enter' && e.target.value) {
                                                  updatePageMeta({ cover: e.target.value });
                                                  setShowCoverInput(false);
                                              }
                                          }}
                                      />
                                      <div className="text-xs font-semibold text-gray-500 mb-2">Solid Colors</div>
                                      <div className="grid grid-cols-6 gap-2 mb-3">
                                          {['gray', 'red', 'orange', 'amber', 'yellow', 'lime', 'green', 'teal', 'cyan', 'blue', 'indigo', 'purple'].map(color => (
                                              <div 
                                                  key={color}
                                                  onClick={() => { updatePageMeta({ cover: `color:${color}` }); setShowCoverInput(false); }}
                                                  className={`w-8 h-8 rounded cursor-pointer hover:scale-110 transition-transform shadow-sm bg-${color}-400`}
                                              />
                                          ))}
                                      </div>
                                      <div className="text-xs font-semibold text-gray-500 mb-2">Gradients</div>
                                      <div className="grid grid-cols-4 gap-2">
                                          {[
                                              'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                                              'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                                              'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                                              'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                                              'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                                              'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
                                              'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
                                              'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                                          ].map((gradient, i) => (
                                              <div 
                                                  key={i}
                                                  onClick={() => { updatePageMeta({ cover: `gradient:${gradient}` }); setShowCoverInput(false); }}
                                                  className="w-full h-8 rounded cursor-pointer hover:scale-105 transition-transform shadow-sm"
                                                  style={{ background: gradient }}
                                              />
                                          ))}
                                      </div>
                                  </div>
                              )}

                              <div className="flex items-end -mt-10 mb-4 gap-1">
                                  <button 
                                      onClick={() => toggleStar(activePage.id, activeNotebookId, activeTabId)} 
                                      className={`p-2 rounded-lg transition-colors ${activePage.starred ? 'text-yellow-400 hover:bg-yellow-50' : 'text-gray-300 hover:text-yellow-400 hover:bg-gray-100'}`}
                                      title={activePage.starred ? 'Remove from favorites' : 'Add to favorites'}
                                  >
                                      <Star size={24} filled={activePage.starred} />
                                  </button>
                                  <div className="relative inline-block">
                                      <div 
                                          className="text-6xl drop-shadow-sm select-none cursor-pointer hover:bg-gray-100/50 rounded p-2 transition-colors icon-picker-trigger"
                                          onClick={() => setShowIconPicker(!showIconPicker)}
                                      >
                                          {activePage.icon || 'ðŸ“„'}
                                      </div>
                                      {showIconPicker && (
                                          <div className="absolute top-full left-0 z-50 bg-white border border-gray-200 shadow-xl rounded-lg p-2 w-64 h-64 overflow-y-auto icon-picker animate-fade-in">
                                              <div className="grid grid-cols-5 gap-1">
                                                  {EMOJIS.map(emoji => (
                                                      <div key={emoji} className="text-2xl cursor-pointer hover:bg-gray-100 p-1 rounded text-center" onClick={() => { updatePageMeta({ icon: emoji }); setShowIconPicker(false); }}>{emoji}</div>
                                                  ))}
                                              </div>
                                          </div>
                                      )}
                                  </div>
                              </div>

                              <div className="mb-8 border-b border-gray-100 pb-4">
                                   <div className="flex items-start gap-3">
                                       <input ref={titleInputRef} className="text-4xl font-bold flex-1 outline-none placeholder-gray-300 py-3 leading-normal bg-transparent" value={activePage.name} onChange={(e) => updateLocalName('page', activePage.id, e.target.value)} onBlur={() => syncRenameToDrive('page', activePage.id)} onClick={(e) => e.target.select()} onKeyDown={handleTitleKeyDown} />
                                   </div>
                                   <div className="text-gray-400 text-xs mt-2 flex gap-4">
                                      <span>Created: Today {new Date(activePage.createdAt).toLocaleDateString()} {new Date(activePage.createdAt).toLocaleTimeString()} â€¢ {rowsForEditor.reduce((acc, r) => acc + r.columns.reduce((ac, c) => ac + c.blocks.length, 0), 0)} blocks</span>
                                   </div>
                              </div>
                              <div 
                                  className="space-y-2"
                                  onDragOver={(e) => {
                                      e.preventDefault();
                                      // Check if dragging files
                                      if (e.dataTransfer.types.includes('Files')) {
                                          e.dataTransfer.dropEffect = 'copy';
                                      }
                                  }}
                                  onDrop={async (e) => {
                                      e.preventDefault();
                                      
                                      // Check if files are being dropped
                                      const files = Array.from(e.dataTransfer.files);
                                      if (files.length > 0 && isAuthenticated && typeof GoogleAPI !== 'undefined' && activeTab?.driveFolderId) {
                                          // Upload files to Drive
                                          for (const file of files) {
                                              try {
                                                  const uploadedFile = await GoogleAPI.uploadFileToDrive(
                                                      file,
                                                      activeTab.driveFolderId,
                                                      file.name
                                                  );
                                                  
                                                  // Create image block for images, or link block for other files
                                                  if (file.type.startsWith('image/')) {
                                                      const newBlock = {
                                                          id: generateId(),
                                                          type: 'image',
                                                          url: uploadedFile.webViewLink,
                                                          driveFileId: uploadedFile.id
                                                      };
                                                      addBlock('image', newBlock);
                                                  } else {
                                                      // For PDFs and other files, create a link block
                                                      const newBlock = {
                                                          id: generateId(),
                                                          type: 'link',
                                                          content: file.name,
                                                          url: uploadedFile.webViewLink,
                                                          driveFileId: uploadedFile.id
                                                      };
                                                      addBlock('link', newBlock);
                                                  }
                                                  
                                                  showNotification(`Uploaded ${file.name}`, 'success');
                                              } catch (error) {
                                                  console.error('Error uploading file:', error);
                                                  showNotification(`Failed to upload ${file.name}`, 'error');
                                              }
                                          }
                                          return;
                                      }
                                      
                                      // Otherwise, handle block drag-and-drop
                                      handleDrop(e);
                                  }}
                                  onDragEnd={handleBlockDragEnd}
                              >
                                  {(() => {
                                      const totalBlocks = rowsForEditor.reduce((acc, r) => acc + r.columns.reduce((ac, c) => ac + c.blocks.length, 0), 0);
                                      return rowsForEditor.map((row) => (
                                          <div key={row.id} className="flex gap-4 group/row relative">
                                          {row.columns.map((col) => (
                                              <div key={col.id} className="flex-1 min-w-[50px] space-y-2">
                                                  {col.blocks.map((block) => (
                                                      <BlockComponent 
                                                          key={block.id}
                                                          block={block}
                                                          rowId={row.id}
                                                          colId={col.id}
                                                          onUpdate={handleUpdateBlock}
                                                          onDelete={handleRemoveBlock}
                                                          onInsertAfter={handleInsertBlockAfter}
                                                          autoFocusId={autoFocusId}
                                                          onRequestFocus={handleRequestFocus}
                                                          isSelected={selectedBlockId === block.id}
                                                          onHandleClick={handleBlockHandleClick}
                                                          onFocus={handleBlockFocus}
                                                          onDragStart={handleBlockDragStart}
                                                          onDragOver={handleBlockDragOver}
                                                          onDrop={handleDrop}
                                                          dropTarget={dropTarget}
                                                          isLastBlock={totalBlocks === 1}
                                                      />
                                                  ))}
                                              </div>
                                          ))}
                                      </div>
                                  )); })()}
                              </div>
                              
                              <div className="mt-12 pb-20 opacity-50 hover:opacity-70 transition-opacity">
                                <div className="flex flex-wrap justify-center gap-x-4 gap-y-1 text-xs text-gray-500 dark:text-gray-400">
                                    {[
                                        { cmd: '/h1', desc: 'heading' },
                                        { cmd: '/h2', desc: 'subheading' },
                                        { cmd: '/ul', desc: 'bullets' },
                                        { cmd: '/ol', desc: 'numbers' },
                                        { cmd: '/todo', desc: 'checkbox' },
                                        { cmd: '/img', desc: 'image' },
                                        { cmd: '/vid', desc: 'video' },
                                        { cmd: '/link', desc: 'link' },
                                        { cmd: '/div', desc: 'divider' },
                                        { cmd: '/gdoc', desc: 'Google Drive' },
                                    ].map(c => (
                                        <span key={c.cmd} className="whitespace-nowrap">
                                            <span className="font-mono font-medium">{c.cmd}</span>
                                            <span className="text-gray-400 dark:text-gray-500 ml-1">{c.desc}</span>
                                        </span>
                                    ))}
                                </div>
                            </div>
                          </div>
                      </div>
                      )
                  ) : (
                      <div className="flex h-full flex-col items-center justify-center gap-3 text-gray-400">
                          <svg className="w-12 h-12 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                          </svg>
                          <p className="text-sm font-medium">Select a page</p>
                          <p className="text-xs text-gray-500">Choose a page from the list</p>
                      </div>
                  )}
              </div>

              {/* PAGES LIST */}
              {activeTab && (
                  <div className={`${settings.condensedView ? 'w-14' : 'w-56'} border-l border-gray-200 bg-white flex flex-col shadow-inner transition-all duration-200`}>
                      <div className={`p-3 border-b bg-gray-50 flex ${settings.condensedView ? 'justify-center' : 'justify-between'} items-center relative`}>
                          {!settings.condensedView && <span className="font-semibold text-gray-600 text-xs uppercase tracking-wider">Pages</span>}
                          <div className="relative">
                              <button onClick={() => setShowPageTypeMenu(!showPageTypeMenu)} className="hover:bg-gray-200 p-1 rounded transition-colors text-gray-500 page-type-trigger" title="Add page"><Plus size={16} /></button>
                              {showPageTypeMenu && (
                                  <div className="page-type-menu absolute right-0 top-full mt-1 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl z-50 py-1 w-48 animate-fade-in">
                                      <button onClick={() => { addPage(); setShowPageTypeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ“</span> Block Page
                                      </button>
                                      <button onClick={() => { addCanvasPage(); setShowPageTypeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸŽ¨</span> Canvas
                                      </button>
                                      <button onClick={() => { addDatabasePage(); setShowPageTypeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ—„ï¸</span> Database
                                      </button>
                                      <div className="border-t border-gray-100 dark:border-gray-700 my-1"></div>
                                      <button onClick={() => { addCodePage(); setShowPageTypeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">&lt;/&gt;</span> Code Page
                                      </button>
                                      <div className="border-t border-gray-100 dark:border-gray-700 my-1"></div>
                                      <button onClick={() => { 
                                          setShowDocImport(true);
                                          setShowPageTypeMenu(false); 
                                      }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ“„</span> Google Doc
                                      </button>
                                      <button onClick={() => { 
                                          setShowSheetImport(true);
                                          setShowPageTypeMenu(false); 
                                      }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ“Š</span> Google Sheet
                                      </button>
                                      <button onClick={() => { 
                                          setShowSlideImport(true);
                                          setShowPageTypeMenu(false); 
                                      }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ“½ï¸</span> Google Slides
                                      </button>
                                      <div className="border-t border-gray-100 dark:border-gray-700 my-1"></div>
                                      <button onClick={() => {
                                          if (!isAuthenticated) { showNotification('Sign in with Google first', 'error'); setShowPageTypeMenu(false); return; }
                                          setShowPageTypeMenu(false);
                                          GoogleAPI.showDrivePicker((file) => {
                                              addGooglePage(file);
                                          });
                                      }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <GoogleG size={18} /> Google Drive
                                      </button>
                                      <button onClick={() => { setShowUrlImport(true); setShowPageTypeMenu(false); }} className="w-full text-left px-3 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-3 text-sm text-gray-800 dark:text-gray-200">
                                          <span className="text-lg">ðŸ“‘</span> PDF Document
                                      </button>
                                  </div>
                              )}
                          </div>
                      </div>
                      <div className="flex-1 min-h-0 overflow-y-auto">
                          {activeTab.pages.map((page, index) => (
                              <div key={page.id} id={`nav-page-${page.id}`} tabIndex={0} onKeyDown={(e) => handlePageKeyDown(e, page.id, index, activeTab.pages)}
                                  draggable={!editingPageId} onDragStart={(e) => handleNavDragStart(e, 'page', page.id, index)} onDragOver={(e) => e.preventDefault()} onDrop={(e) => handleNavDrop(e, 'page', index)}
                                  className={`page-item group flex items-center ${settings.condensedView ? 'justify-center' : 'gap-2'} p-3 border-b cursor-pointer text-sm outline-none transition-all ${activePageId === page.id ? 'bg-gray-100 border-l-4 border-l-blue-500' : 'hover:bg-gray-50 border-l-4 border-l-transparent'}`}
                                  onClick={() => { if (activePageId === page.id) return; selectPage(page.id); }}
                                  title={settings.condensedView ? page.name : undefined}>
                                  <span className={settings.condensedView ? 'text-xl' : 'mr-1 flex-shrink-0'}>{page.icon || 'ðŸ“„'}</span>
                                  {!settings.condensedView && (activePageId === page.id && editingPageId === page.id ? (
                                      <input className="flex-1 min-w-0 bg-transparent outline-none page-input" value={page.name} onChange={(e) => updateLocalName('page', page.id, e.target.value)} onFocus={(e) => e.target.select()} onBlur={() => { syncRenameToDrive('page', page.id); setEditingPageId(null); }} onKeyDown={(e) => { e.stopPropagation(); if (e.key === 'Enter') e.target.blur(); }} autoFocus />
                                  ) : ( 
                                      <div className="flex-1 min-w-0 truncate" onClick={(e) => { if(activePageId === page.id) { e.stopPropagation(); setEditingPageId(page.id); } }}>{page.name}</div> 
                                  ))}
                                  {!settings.condensedView && (
                                    <div className="flex items-center gap-1 flex-shrink-0">
                                      <button onClick={(e) => { e.stopPropagation(); toggleStar(page.id, activeNotebookId, activeTabId); }} className={`${page.starred ? 'text-yellow-400' : 'opacity-0 group-hover:opacity-100 text-gray-400 hover:text-yellow-400'} transition-all`} title={page.starred ? 'Remove from favorites' : 'Add to favorites'}>
                                        <Star size={14} filled={page.starred} />
                                      </button>
                                      <button onClick={(e) => { e.stopPropagation(); executeDelete('page', page.id); }} className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-500 transition-all"><X size={14} /></button>
                                    </div>
                                  )}
                              </div>
                          ))}
                      </div>
                  </div>
              )}
          </div>
          
          {activeTabMenu && (
              <div className="fixed bg-white border border-gray-200 shadow-xl rounded-lg p-3 z-[9999] tab-settings-menu animate-fade-in" style={{ top: activeTabMenu.top, left: activeTabMenu.left }}>
                  <div className="text-[10px] font-bold text-gray-400 uppercase mb-2">Section Color</div>
                  <div className="grid grid-cols-5 gap-2 mb-3">
                      {COLORS.map(c => ( <div key={c.name} onClick={() => updateTabColor(activeTabMenu.id, c.name)} className={`w-5 h-5 rounded-full cursor-pointer bg-${c.name}-500 hover:scale-125 transition-transform shadow-sm`}></div> ))}
                  </div>
                  <div className="border-t border-gray-100 my-2"></div>
                  <button onClick={() => executeDelete('tab', activeTabMenu.id)} className="w-full text-left text-xs text-red-600 p-1.5 hover:bg-red-50 rounded flex items-center gap-2 transition-colors"><Trash2 size={12}/> Delete Section</button>
              </div>
          )}

          {blockMenu && (() => {
              const menuBlock = findBlockInRows(rowsForEditor, blockMenu.id);
              return menuBlock && (
              <div className="fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-600 shadow-xl rounded-lg p-2 z-[9999] block-menu animate-fade-in" style={{ top: blockMenu.top, left: blockMenu.left }}>
                  <div className="mb-2">
                      <div className="text-[10px] font-bold text-gray-400 dark:text-gray-500 uppercase mb-1.5">Change type</div>
                      <select
                          value={menuBlock.type}
                          onChange={(e) => changeBlockType(blockMenu.id, e.target.value)}
                          className="w-full text-xs border border-gray-300 dark:border-gray-600 rounded px-2 py-1.5 bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                          {BLOCK_TYPES.map(({ type, label }) => (
                              <option key={type} value={type}>{label}</option>
                          ))}
                      </select>
                  </div>
                  <div className="border-t border-gray-100 dark:border-gray-600 my-2"></div>
                  <div className="grid grid-cols-5 gap-2">
                      <div onClick={() => updateBlockColor(blockMenu.id, null)} className="w-5 h-5 rounded-full border border-gray-300 dark:border-gray-500 flex items-center justify-center cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700"><X size={10}/></div>
                      {COLORS.map(c => ( <div key={c.name} onClick={() => updateBlockColor(blockMenu.id, c.name)} className={`w-5 h-5 rounded-full cursor-pointer bg-${c.name}-500 hover:scale-125 transition-transform shadow-sm`}></div> ))}
                  </div>
              </div>
              );
          })()}

          {notebookIconPicker && (
              <div className="fixed bg-white border border-gray-200 shadow-xl rounded-lg p-2 z-[9999] notebook-icon-picker animate-fade-in w-64 h-64 overflow-y-auto" style={{ top: notebookIconPicker.top, left: notebookIconPicker.left }}>
                  <div className="grid grid-cols-5 gap-1">
                      {EMOJIS.slice(0, 200).map((emoji, i) => (
                          <div key={i} className="text-xl cursor-pointer hover:bg-gray-100 p-1 rounded text-center" onClick={() => updateNotebookIcon(notebookIconPicker.id, emoji)}>{emoji}</div>
                      ))}
                  </div>
              </div>
          )}

          {tabIconPicker && (
              <div className="fixed bg-white border border-gray-200 shadow-xl rounded-lg p-2 z-[9999] tab-icon-picker animate-fade-in w-64 h-64 overflow-y-auto" style={{ top: tabIconPicker.top, left: tabIconPicker.left }}>
                  <div className="grid grid-cols-5 gap-1">
                      {EMOJIS.slice(0, 200).map((emoji, i) => (
                          <div key={i} className="text-xl cursor-pointer hover:bg-gray-100 p-1 rounded text-center" onClick={() => updateTabIcon(tabIconPicker.id, emoji)}>{emoji}</div>
                      ))}
                  </div>
              </div>
          )}

          {notification && <div className="fixed bottom-4 right-4 bg-gray-800 text-white px-4 py-2 rounded-full shadow-lg z-[10000] animate-bounce-in">{notification.message}</div>}

          {showUrlImport && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <span className="text-2xl">ðŸ“‘</span>
                              Add PDF Document
                          </h3>
                          <button onClick={() => { setShowUrlImport(false); setUrlImportValue(''); }} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              PDF URL
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://example.com/document.pdf"
                              value={urlImportValue}
                              onChange={(e) => setUrlImportValue(e.target.value)}
                              onKeyDown={(e) => { if (e.key === 'Enter') handleUrlImport(); }}
                              autoFocus
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              Enter a direct link to a PDF file or a Google Drive sharing link. The PDF will be displayed using Google's PDF viewer.
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => { setShowUrlImport(false); setUrlImportValue(''); }}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={handleUrlImport}
                              disabled={!urlImportValue}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Add Page
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {/* Google Drive Import Modal */}
          {showDriveImport && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <GoogleG size={20} /> Add from Google Drive
                          </h3>
                          <button onClick={() => { setShowDriveImport(false); setDriveImportUrl(''); }} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <button 
                              onClick={() => {
                                  GoogleAPI.showDrivePicker((file) => {
                                      addGooglePage(file);
                                      setShowDriveImport(false);
                                      setDriveImportUrl('');
                                  });
                              }}
                              className="w-full py-3 px-4 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors flex items-center justify-center gap-2"
                          >
                              <FolderOpen size={18} /> Browse My Drive
                          </button>
                      </div>

                      <div className="flex items-center gap-3 mb-6">
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                          <span className="text-sm text-gray-400">OR</span>
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              Paste a Google Drive URL
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://docs.google.com/... or https://drive.google.com/..."
                              value={driveImportUrl}
                              onChange={(e) => setDriveImportUrl(e.target.value)}
                              autoFocus
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              Paste a link to a Google Doc, Sheet, Slides, or any Drive file shared with you.
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => { setShowDriveImport(false); setDriveImportUrl(''); }}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => {
                                  if (addGooglePageFromUrl(driveImportUrl)) {
                                      setShowDriveImport(false);
                                      setDriveImportUrl('');
                                  }
                              }}
                              disabled={!driveImportUrl}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Add Page
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {/* Google Doc Import Modal */}
          {showDocImport && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <span className="text-2xl">ðŸ“„</span> Add Google Doc
                          </h3>
                          <button onClick={() => { setShowDocImport(false); setDocImportUrl(''); }} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <button 
                              title="Feature coming soon"
                              className="w-full py-3 px-4 bg-gray-100 dark:bg-gray-700 text-gray-400 font-medium rounded-lg cursor-not-allowed flex items-center justify-center gap-2"
                          >
                              <FilePlus size={18} /> New Document
                          </button>
                      </div>

                      <div className="flex items-center gap-3 mb-6">
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                          <span className="text-sm text-gray-400">OR</span>
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              Google Doc URL
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://docs.google.com/document/d/..."
                              value={docImportUrl}
                              onChange={(e) => setDocImportUrl(e.target.value)}
                              onKeyDown={(e) => { if (e.key === 'Enter' && docImportUrl) { addGooglePageFromUrl(docImportUrl); setShowDocImport(false); setDocImportUrl(''); } }}
                              autoFocus
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              Paste a link to a Google Doc shared with "anyone with link"
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => { setShowDocImport(false); setDocImportUrl(''); }}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => {
                                  if (addGooglePageFromUrl(docImportUrl)) {
                                      setShowDocImport(false);
                                      setDocImportUrl('');
                                  }
                              }}
                              disabled={!docImportUrl}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Add Page
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {/* Google Sheet Import Modal */}
          {showSheetImport && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <span className="text-2xl">ðŸ“Š</span> Add Google Sheet
                          </h3>
                          <button onClick={() => { setShowSheetImport(false); setSheetImportUrl(''); }} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <button 
                              title="Feature coming soon"
                              className="w-full py-3 px-4 bg-gray-100 dark:bg-gray-700 text-gray-400 font-medium rounded-lg cursor-not-allowed flex items-center justify-center gap-2"
                          >
                              <FilePlus size={18} /> New Spreadsheet
                          </button>
                      </div>

                      <div className="flex items-center gap-3 mb-6">
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                          <span className="text-sm text-gray-400">OR</span>
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              Google Sheet URL
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://docs.google.com/spreadsheets/d/..."
                              value={sheetImportUrl}
                              onChange={(e) => setSheetImportUrl(e.target.value)}
                              onKeyDown={(e) => { if (e.key === 'Enter' && sheetImportUrl) { addGooglePageFromUrl(sheetImportUrl); setShowSheetImport(false); setSheetImportUrl(''); } }}
                              autoFocus
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              Paste a link to a Google Sheet shared with "anyone with link"
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => { setShowSheetImport(false); setSheetImportUrl(''); }}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => {
                                  if (addGooglePageFromUrl(sheetImportUrl)) {
                                      setShowSheetImport(false);
                                      setSheetImportUrl('');
                                  }
                              }}
                              disabled={!sheetImportUrl}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Add Page
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {/* Google Slides Import Modal */}
          {showSlideImport && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <span className="text-2xl">ðŸ“½ï¸</span> Add Google Slides
                          </h3>
                          <button onClick={() => { setShowSlideImport(false); setSlideImportUrl(''); }} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <button 
                              title="Feature coming soon"
                              className="w-full py-3 px-4 bg-gray-100 dark:bg-gray-700 text-gray-400 font-medium rounded-lg cursor-not-allowed flex items-center justify-center gap-2"
                          >
                              <FilePlus size={18} /> New Presentation
                          </button>
                      </div>

                      <div className="flex items-center gap-3 mb-6">
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                          <span className="text-sm text-gray-400">OR</span>
                          <div className="flex-1 h-px bg-gray-200 dark:bg-gray-600"></div>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              Google Slides URL
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://docs.google.com/presentation/d/..."
                              value={slideImportUrl}
                              onChange={(e) => setSlideImportUrl(e.target.value)}
                              onKeyDown={(e) => { if (e.key === 'Enter' && slideImportUrl) { addGooglePageFromUrl(slideImportUrl); setShowSlideImport(false); setSlideImportUrl(''); } }}
                              autoFocus
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              Paste a link to a Google Slides presentation shared with "anyone with link"
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => { setShowSlideImport(false); setSlideImportUrl(''); }}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => {
                                  if (addGooglePageFromUrl(slideImportUrl)) {
                                      setShowSlideImport(false);
                                      setSlideImportUrl('');
                                  }
                              }}
                              disabled={!slideImportUrl}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Add Page
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {showEditEmbed && activePage && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-3 dark:text-white">
                              <Edit3 size={20} /> Edit Page
                          </h3>
                          <button onClick={() => setShowEditEmbed(false)} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg">
                              <X size={20} className="dark:text-white" />
                          </button>
                      </div>

                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              {activePage.type === 'doc' ? 'Google Doc URL' : 
                               activePage.type === 'sheet' ? 'Google Sheet URL' : 
                               activePage.type === 'slide' ? 'Google Slides URL' :
                               activePage.type === 'web' ? 'Web Page URL' :
                               activePage.type === 'pdf' ? 'PDF URL' : 'URL'}
                          </label>
                          <input 
                              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                              placeholder="https://..."
                              value={editEmbedUrl}
                              onChange={(e) => setEditEmbedUrl(e.target.value)}
                          />
                          <p className="text-xs text-gray-400 mt-2">
                              {['doc', 'sheet', 'slide'].includes(activePage.type) 
                                  ? 'Paste a Google Docs, Sheets, or Slides URL to update the source.'
                                  : 'Update the URL for this embedded page.'}
                          </p>
                      </div>

                      <div className="flex justify-end gap-3">
                          <button 
                              onClick={() => setShowEditEmbed(false)}
                              className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={handleSaveEmbed}
                              disabled={!editEmbedUrl}
                              className="px-5 py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          >
                              Save Changes
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {itemToDelete && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-sm w-full p-6 animate-fade-in">
                      <h3 className="font-bold text-xl mb-2 flex items-center gap-2 dark:text-white"><AlertCircle className="text-red-500" /> Confirm Deletion</h3>
                      <p className="text-gray-600 dark:text-gray-300 mb-6 leading-relaxed">Are you sure you want to delete this {itemToDelete.type}? All contents will be lost forever.</p>
                      <div className="flex justify-end gap-3">
                          <button onClick={() => setItemToDelete(null)} className="px-5 py-2 font-medium text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors">Cancel</button>
                          <button onClick={confirmDelete} className="px-5 py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition-colors shadow-lg">Delete</button>
                      </div>
                  </div>
              </div>
          )}

          {/* Sign Out Confirmation Dialog */}
          {showSignOutConfirm && (
              <div className="fixed inset-0 bg-black/50 z-[10001] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-6 animate-fade-in max-w-sm w-full">
                      <h3 className="font-bold text-lg mb-2 dark:text-white">Sign out of Google?</h3>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-6">Your data will remain synced. You can sign back in anytime.</p>
                      <div className="flex gap-3 justify-end">
                          <button 
                              onClick={() => setShowSignOutConfirm(false)} 
                              className="px-4 py-2 text-sm text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={() => { handleSignOut(); setShowSignOutConfirm(false); }} 
                              className="px-4 py-2 text-sm bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors"
                          >
                              Yes, Sign Out
                          </button>
                      </div>
                  </div>
              </div>
          )}

          {showSettings && (
              <div className="fixed inset-0 bg-black/50 z-[10000] flex items-center justify-center p-4 backdrop-blur-sm">
                  <div className="bg-white dark:bg-gray-800 rounded-xl shadow-2xl max-w-md w-full p-6 animate-fade-in settings-modal">
                      <div className="flex items-center justify-between mb-6">
                          <h3 className="font-bold text-xl flex items-center gap-2 dark:text-white"><Settings size={20} /> Settings</h3>
                          <button onClick={() => setShowSettings(false)} className="p-1 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg"><X size={20} className="dark:text-white" /></button>
                      </div>
                      
                      {/* Theme */}
                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Theme</label>
                          <div className="flex gap-2">
                              {[
                                  { value: 'light', icon: <Sun size={16} />, label: 'Light' },
                                  { value: 'dark', icon: <Moon size={16} />, label: 'Dark' },
                                  { value: 'system', icon: <Monitor size={16} />, label: 'System' },
                              ].map(opt => (
                                  <button
                                      key={opt.value}
                                      onClick={() => setSettings(s => ({ ...s, theme: opt.value }))}
                                      className={`flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-lg border transition-all ${
                                          settings.theme === opt.value 
                                              ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400' 
                                              : 'border-gray-200 dark:border-gray-600 hover:bg-gray-50 dark:hover:bg-gray-700 text-gray-600 dark:text-gray-300'
                                      }`}
                                  >
                                      {opt.icon}
                                      <span className="text-sm font-medium">{opt.label}</span>
                                  </button>
                              ))}
                          </div>
                      </div>

                      {/* Max Columns */}
                      <div className="mb-6">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-2"><Columns size={16} /> Max Columns per Row</span>
                          </label>
                          <div className="flex items-center gap-3">
                              <input 
                                  type="range" 
                                  min="1" 
                                  max="6" 
                                  value={settings.maxColumns} 
                                  onChange={(e) => setSettings(s => ({ ...s, maxColumns: parseInt(e.target.value) }))}
                                  className="flex-1 accent-blue-500"
                              />
                              <span className="w-8 text-center font-bold text-lg dark:text-white">{settings.maxColumns}</span>
                          </div>
                          <p className="text-xs text-gray-400 mt-1">Controls how many columns you can create when dragging blocks side-by-side</p>
                      </div>

                      <div className="border-t dark:border-gray-700 pt-4">
                          <button 
                              onClick={() => setShowSettings(false)} 
                              className="w-full py-2 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition-colors"
                          >
                              Done
                          </button>
                      </div>
                  </div>
              </div>
          )}
        </div>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);</script>
</body>
</html>